[
  {
    "objectID": "posts/rtables/multiple_levels_calculation_1.html#multiple-lelvels-calculation",
    "href": "posts/rtables/multiple_levels_calculation_1.html#multiple-lelvels-calculation",
    "title": "Mutiple level calculation 1",
    "section": "Multiple lelvels calculation",
    "text": "Multiple lelvels calculation\nMultipile levels calculation for categorical variable is the most common cases in Table, e.g. PCSA, Exposure tables.\nIn this section, we will explore how to produce these output in rtables.\nBelow is the test data:\n\ndf <- data.frame(SUBJID = c(rep('S1', 5), rep(\"S2\", 4), rep(\"S3\", 2)),\n                 ASEQ = c(1:5, 1:4, 1:2),\n                 GROUP = factor(c(rep('A', 5), rep(\"B\", 4), rep('A', 2)), levels = c(\"A\", \"B\")),\n                 PARAMCD = c('TEST_1', 'TEST_1', 'TEST_1', 'TEST_1', 'TEST_2', 'TEST_1', 'TEST_1', 'TEST_2', 'TEST_2', 'TEST_1', 'TEST_2'),\n                 CRIT = c('LEVEL_2_1','LEVEL_2_1', 'LEVEL_2_2', NA_character_, 'LEVEL_2_a', 'LEVEL_2_1', NA_character_, 'LEVEL_2_a', 'LEVEL_2_b', NA_character_, 'LEVEL_2_b'))\n\n\n\n\n\n \n  \n    SUBJID \n    ASEQ \n    GROUP \n    PARAMCD \n    CRIT \n  \n \n\n  \n    S1 \n    1 \n    A \n    TEST_1 \n    LEVEL_2_1 \n  \n  \n    S1 \n    2 \n    A \n    TEST_1 \n    LEVEL_2_1 \n  \n  \n    S1 \n    3 \n    A \n    TEST_1 \n    LEVEL_2_2 \n  \n  \n    S1 \n    4 \n    A \n    TEST_1 \n    NA \n  \n  \n    S1 \n    5 \n    A \n    TEST_2 \n    LEVEL_2_a \n  \n  \n    S2 \n    1 \n    B \n    TEST_1 \n    LEVEL_2_1 \n  \n  \n    S2 \n    2 \n    B \n    TEST_1 \n    NA \n  \n  \n    S2 \n    3 \n    B \n    TEST_2 \n    LEVEL_2_a \n  \n  \n    S2 \n    4 \n    B \n    TEST_2 \n    LEVEL_2_b \n  \n  \n    S3 \n    1 \n    A \n    TEST_1 \n    NA \n  \n  \n    S3 \n    2 \n    A \n    TEST_2 \n    LEVEL_2_b \n  \n\n\n\n\n\nNow, we need to take the PARAMCD as 1st level, and the CRIT as 2nd level to calculate the frequency of each TEST, it will be a table like PCSA."
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_2.html#wrap-the-analysis-function",
    "href": "posts/rtables/multiple_levels_calculation_2.html#wrap-the-analysis-function",
    "title": "Mutiple level calculation 2",
    "section": "Wrap the analysis function",
    "text": "Wrap the analysis function\nThe function is too long and it’s not convient mixed with the layout of rtbales. For better user experience, we can create a function summarise_vars_categorical\n\nwrap the analysis function as summarise_vars_categorical_afun\nwrap the summarise_vars_categorical_afun and the extral_args within the summarise_vars_categorical\n\nThen user can passed all the analysis variables and customized argument by a single function summarise_vars_categorical.\n\n# wrap the analysis function\nsummarise_vars_categorical_afun <- function(df, .N_col, .var, .N_row,\n                                            format = 'n(%)',\n                                            decimal = 1,\n                                            n_unique_keys = NULL,\n                                            N_unique_keys = NULL,\n                                            show_N_item = FALSE,\n                                            add_Number = FALSE,\n                                            missing_rm = TRUE,\n                                            missing_label = NULL,\n                                            indent_mod = 0L,\n                                            ...) {\n\n\n  if(missing_rm){\n    df <- df %>% filter(!(!!as.name(.var) %in% \"Missing_value_flag\"))\n  }\n\n  df_n <- df\n  if(!is.null(n_unique_keys)){\n    df_n <- df %>% distinct(across(c(n_unique_keys, .var)), .keep_all = TRUE)\n  }\n  x <- df_n[[.var]]\n  if(!is.null(N_unique_keys)){\n    cus_N_col <- df %>% distinct(across(N_unique_keys)) %>% nrow()\n  }else{\n    cus_N_col <- .N_col\n  }\n\n  lst_body <- lapply(\n    as.list(table(x)),\n    function(xi) {\n      rcell(format_values_helper(xi, cus_N_col, type = format),\n            format = sprintf_format_helper(xi, cus_N_col, 1, type = format),\n            indent_mod = indent_mod\n      )\n    }\n  )\n  if(add_Number){\n    lst_body <- append(setNames(list(rcell(cus_N_col,\n                                           format = \"xx\",\n                                           indent_mod = indent_mod)), 'Number'), lst_body)\n  }\n\n  if(is.null(missing_label)){\n    if(\"Missing_value_flag\" %in% names(lst_body)){\n      lst_body <- purrr::list_modify(lst_body, \"Missing_value_flag\" = NULL)\n    }\n  }else{\n    lst_body <- lst_body %>%\n      setNames(gsub(\"Missing_value_flag\", missing_label, names(.)))\n\n  }\n\n  in_rows(\n    .list = c(\n      lst_body,\n      # add empty row, in .list obj\n      \" \" = rcell(\"\", format = \"xx\")\n    )\n  )\n}\n\n# wrap the summarise_vars_categorical_afun and the extral_args\nsummarise_vars_categorical <- function(lyt,\n                                       vars,\n                                       var_labels,\n                                       format = 'n(%)',\n                                       decimal = 1,\n                                       n_unique_keys = NULL,\n                                       N_unique_keys = NULL,\n                                       show_N_item = FALSE,\n                                       add_Number = FALSE,\n                                       missing_rm = TRUE,\n                                       missing_label = NULL,\n                                       show_labels='visible',\n                                       indent_mod = 0L, ...){\n  rtables::analyze(lyt, vars, var_labels,\n                   afun = summarise_vars_categorical_afun,\n                   extra_args = list(format = format,\n                                     decimal = decimal,\n                                     n_unique_keys = n_unique_keys,\n                                     N_unique_keys = N_unique_keys,\n                                     show_N_item = show_N_item,\n                                     add_Number = add_Number,\n                                     missing_rm = missing_rm,\n                                     missing_label = missing_label),\n                   show_labels = show_labels, indent_mod = indent_mod)\n}\n\n\nlyt <- basic_table() %>%\n  split_cols_by(\"GROUP\") %>%\n  add_overall_col(\"All\") %>%\n  summarise_vars_categorical(vars = c('TEST_1_fmt', 'TEST_2_fmt'),\n                             var_labels = c('This is test 1', 'This is test 2'),\n                             format = 'n/N(%)',\n                             n_unique_keys = c(\"SUBJID\"),\n                             N_unique_keys = c(\"SUBJID\"),\n                             add_Number = TRUE,\n                             missing_rm = FALSE\n\n  )\n\ntbl <- lyt %>% rtables::build_table(df1, col_counts = col_counts)\n\n\n\n\nABAll(N=2)(N=1)(N=3)This is test 1  Number213  1 of level 21/2 (50.0)1/1 (100)2/3 (66.7)  2 of level 21/2 (50.0)0/11/3 (33.3)  3 of level 20/20/10/3  Missing_value_flag   This is test 2  Number213  a of level 21/2 (50.0)1/1 (100)2/3 (66.7)  b of level 21/2 (50.0)1/1 (100)2/3 (66.7)  c of level 20/20/10/3  Missing_value_flag"
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_3.html#method-2",
    "href": "posts/rtables/multiple_levels_calculation_3.html#method-2",
    "title": "Mutiple level calculation 3",
    "section": "Method 2",
    "text": "Method 2\n\n\n\nAnother powerful function rtables provide to us is the function summarize_row_groups, which can be used to add a content row of summary counts.\nThis function need a different data structure from the rtable::analyze(). rtable::analyze() is kind of the columns-based analysis, the summarize_row_groups is more like the rows-based analysis.\nTo build the data:\n\ncreate the 1st level columns by PARAMCD, TEST_1_level_1, TEST_2_level_1\nCreate the 2rd level columns by CRIT, TEST_1_level_2, TEST_2_level_2\n\n\nparam_coding <- c('TEST_1' = 'This is test 1',\n                  'TEST_2' = 'This is test 2')\ndf <- df %>% mutate(PARAML = param_coding[PARAMCD])\ntmp <- df\ntmp[, str_c(names(param_coding), '_level_1')] <- NA_character_\n\n\n# tmp1 <- df %>% mutate(TEST_1_level_1 = ifelse(PARAMCD == 'TEST_1', PARAMCD, NA_character_),\n#                       TEST_2_level_1 = ifelse(PARAMCD == 'TEST_2', PARAMCD, NA_character_),\n#                       TEST_1_aval_1 = ifelse(!is.na(TEST_1_level_1), 1, NA_character_),\n#                       TEST_1_aval_1 = ifelse(!is.na(TEST_2_level_1), 1, NA_character_),\n#                       TEST_1_level_2 = ifelse(PARAMCD == 'TEST_1' & !is.na(CRIT), CRIT, NA_character_),\n#                       TEST_2_level_2 = ifelse(PARAMCD == 'TEST_2' & !is.na(CRIT), CRIT, NA_character_),\n#                       TEST_1_aval_2 = ifelse(!is.na(TEST_1_level_2), 1, NA_character_),\n#                       TEST_2_aval_2 = ifelse(!is.na(TEST_2_level_2), 1, NA_character_)\n#                       )\n\ntmp1 <- tmp %>%\n  mutate(\n    across(\n      .cols = c(\"TEST_1_level_1\", \"TEST_2_level_1\"),\n      .fns = \\(x)  factor(ifelse(grepl(gsub(\"_level_1\", \"\",cur_column()), PARAMCD), PARAML, x))\n    )\n    ,\n    across(c(do.call(str_c, expand.grid(names(param_coding), c('_level_1')))),\n           ~ifelse(!is.na(.x), 1, .x),\n           .names = \"{gsub('level','aval', .col)}\")\n    )\n\n\ntmp1[, str_c(names(param_coding), '_level_2')] <- NA_character_\n\n\nfmt <- list(\n  'TEST_1_level_2' = c('LEVEL_2_1' = '1 of level 2',\n               'LEVEL_2_2' = '2 of level 2',\n               'LEVEL_2_3' = '3 of level 2'),\n  \"TEST_2_level_2\" = c('LEVEL_2_a' = 'a of level 2',\n               'LEVEL_2_b' = 'b of level 2',\n               'LEVEL_2_c' = 'c of level 2')\n)\n\ntmp2 <- tmp1 %>%\n  mutate(\n    across(\n      .cols = c(\"TEST_1_level_2\", \"TEST_2_level_2\"),\n      .fns = \\(x)  factor(ifelse(grepl(gsub(\"_level_2\", \"\",cur_column()), PARAMCD) & !is.na(CRIT) , fmt[[cur_column()]][CRIT], x), levels = fmt[[cur_column()]])\n    ),\n    across(c(do.call(str_c, expand.grid(names(param_coding), c('_level_2')))),\n           ~ifelse(!is.na(.x), 1, .x),\n           .names = \"{gsub('level','aval', .col)}\")\n  )"
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_3.html#wrap-the-analysis-function",
    "href": "posts/rtables/multiple_levels_calculation_3.html#wrap-the-analysis-function",
    "title": "Mutiple level calculation 3",
    "section": "Wrap the analysis function",
    "text": "Wrap the analysis function\n\ntbl_recipe <- basic_table() %>%\n  rtables::split_cols_by(var = \"GROUP\") %>%\n  add_overall_col(\"All\") %>%\n  ## 1st-level row-wise splitting, and its column-wise analysis function\n  rtables::split_rows_by(\"TEST_1_level_1\", split_fun = remove_split_levels(c(NA_character_))) %>%\n  rtables::summarize_row_groups(cfun = count_items_cfun,\n                                extra_args = list(n_var = \"TEST_1_aval_1\", n_unique_keys = \"SUBJID\", hide_value = TRUE)) %>%\n  ## 2nd-level row-wise splitting, and its column-wise analysis function, use n_unique_keys to remove duplicated records\n  rtables::split_rows_by(\"TEST_1_level_2\") %>%\n  rtables::summarize_row_groups(cfun = count_items_cfun, extra_args = list(\n    n_var = \"TEST_1_aval_2\", n_unique_keys = c(\"SUBJID\"), N_var = \"TEST_1_aval_1\", N_unique_keys = \"SUBJID\",\n    empty_row = TRUE\n  ))\n\ncol_counts_df <- tmp2 %>%\n  distinct(SUBJID, GROUP)\ncol_counts <- table(col_counts_df$GROUP)\ncol_counts <- c(col_counts, sum(col_counts))\ntest1_tbl <- tbl_recipe %>%\n  rtables::build_table(tmp2, col_counts = col_counts)\n\n\n\n\nABAll(N=2)(N=1)(N=3)This is test 1  1 of level 21/2 (50.0)1/1 (100)2/3 (66.7)  2 of level 21/2 (50.0)0/11/3 (33.3)  3 of level 20/20/10/3   \n\n\n\ncount_items_cfun <- function(df,\n                        labelstr,\n                        .spl_context,\n                        n_var,\n                        n_unique_keys = NULL,\n                        N_var = NULL,\n                        N_index = NULL,\n                        N_unique_keys = NULL,\n                        empty_row = FALSE,\n                        hide_value = FALSE,\n                        format = \"n/N(%)\") {\n\n  # caculate the value\n  df_n <- df\n  if (!is.null(n_unique_keys)) {\n    df_n <- df %>% distinct(across(n_unique_keys), .keep_all = T)\n  }\n  x <- df_n[[n_var]]\n  n <- sum(x[!is.na(x)])\n\n  cur_index <- which(.spl_context[[\"value\"]] == labelstr)\n  # View(df)\n  if (!is.null(N_var)) {\n\n    # get N of parent for denomitor caculation\n    if (!is.null(N_index)) {\n      parent_df <- .spl_context$full_parent_df[[N_index]][.spl_context[[\"cur_col_subset\"]][[N_index]], ]\n    } else {\n      parent_df <- .spl_context$full_parent_df[[cur_index - 1]][.spl_context[[\"cur_col_subset\"]][[cur_index - 1]], ]\n    }\n\n    if (!is.null(N_unique_keys)) {\n      parent_df <-  parent_df %>% distinct(across(N_unique_keys), .keep_all = T)\n    }\n\n    parent_x <- parent_df[[N_var]]\n    parent_N <- sum(!is.na(parent_x[!is.na(parent_x)]))\n\n    # get current value to check if it match the last value of levels, for empty row\n    # !Start\n    var_levels <- length(.spl_context$split)\n    curr_var_level_val <- .spl_context$value[[nrow(.spl_context)]]\n    last_var_level_val <-\n      .spl_context$full_parent_df[[nrow(.spl_context)]][[.spl_context$split[var_levels]]] %>%\n      levels() %>%\n      tail(1)\n    if (curr_var_level_val == last_var_level_val & empty_row) {\n      ret <- in_rows(\n        .names = c(labelstr, \" \"),\n        .list = list(c(format_values_helper(n, parent_N, type = format)), NULL),\n        .formats = c(sprintf_format_helper(n, parent_N, type = format), \"xx\")\n      )\n    } else {\n      rc <- rcell(\n        x = format_values_helper(n, parent_N, type = format),\n        format = sprintf_format_helper(n, parent_N, type = format)\n      )\n      ret <- in_rows(.names = labelstr, rc)\n    }\n    # !End\n  } else {\n    rc <- rcell(\n      x = ifelse(hide_value, \"\", n),\n      format = \"xx\"\n    )\n    ret <- in_rows(.names = labelstr, rc)\n  }\n  return(ret)\n}\n\n\n\n\ntbl_recipe <- basic_table() %>%\n  rtables::split_cols_by(var = \"GROUP\") %>%\n  add_overall_col(\"All\") %>%\n  ## 1st-level row-wise splitting, and its column-wise analysis function\n  rtables::split_rows_by(\"TEST_2_level_1\", split_fun = remove_split_levels(c(NA_character_))) %>%\n  rtables::summarize_row_groups(cfun = count_items_cfun,\n                                extra_args = list(n_var = \"TEST_2_aval_1\", n_unique_keys = \"SUBJID\", hide_value = TRUE)) %>%\n  ## 2nd-level row-wise splitting, and its column-wise analysis function, use n_unique_keys to remove duplicated records\n  rtables::split_rows_by(\"TEST_2_level_2\") %>%\n  rtables::summarize_row_groups(cfun = count_items_cfun, extra_args = list(\n    n_var = \"TEST_2_aval_2\", n_unique_keys = c(\"SUBJID\"), N_var = \"TEST_2_aval_1\", N_unique_keys = \"SUBJID\",\n    empty_row = TRUE\n  ))\n\n\ntest2_tbl <- tbl_recipe %>%\n  rtables::build_table(tmp2, col_counts = col_counts)\n\n\n\n\nABAll(N=2)(N=1)(N=3)This is test 2  a of level 21/2 (50.0)1/1 (100)2/3 (66.7)  b of level 21/2 (50.0)1/1 (100)2/3 (66.7)  c of level 20/20/10/3   \n\n\n\ntbl2 <- rbind(test1_tbl, test2_tbl)\n\n\n\n\nABAll(N=2)(N=1)(N=3)This is test 1  1 of level 21/2 (50.0)1/1 (100)2/3 (66.7)  2 of level 21/2 (50.0)0/11/3 (33.3)  3 of level 20/20/10/3   This is test 2  a of level 21/2 (50.0)1/1 (100)2/3 (66.7)  b of level 21/2 (50.0)1/1 (100)2/3 (66.7)  c of level 20/20/10/3"
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_4.html#summary-counts-more-than-2rd-level",
    "href": "posts/rtables/multiple_levels_calculation_4.html#summary-counts-more-than-2rd-level",
    "title": "Mutiple level calculation 4",
    "section": "Summary counts more than 2rd level",
    "text": "Summary counts more than 2rd level\n\n\n\n\n\n\n\n \n  \n    SUBJID \n    GROUP \n    AVAL \n    level_1 \n    level_2 \n    level_3 \n    aval_1 \n    aval_2 \n    aval_3 \n  \n \n\n  \n    S1 \n    B \n    14 \n    level 1 \n    level 2 \n    NA \n    1 \n    1 \n    NA \n  \n  \n    S2 \n    A \n    19 \n    NA \n    NA \n    NA \n    NA \n    NA \n    NA \n  \n  \n    S3 \n    B \n    3 \n    NA \n    NA \n    NA \n    NA \n    NA \n    NA \n  \n  \n    S4 \n    B \n    2 \n    NA \n    NA \n    NA \n    NA \n    NA \n    NA \n  \n  \n    S5 \n    A \n    15 \n    level 1 \n    level 2 \n    NA \n    1 \n    1 \n    NA \n  \n  \n    S6 \n    B \n    5 \n    level 1 \n    NA \n    NA \n    1 \n    NA \n    NA \n  \n  \n    S7 \n    C \n    10 \n    level 1 \n    level 2 \n    level_3 \n    1 \n    1 \n    1 \n  \n  \n    S8 \n    B \n    13 \n    level 1 \n    level 2 \n    NA \n    1 \n    1 \n    NA \n  \n  \n    S9 \n    A \n    7 \n    level 1 \n    level 2 \n    NA \n    1 \n    1 \n    NA \n  \n  \n    S10 \n    B \n    20 \n    NA \n    NA \n    NA \n    NA \n    NA \n    NA \n  \n\n\n\n\n\n\ncol_counts <- table(df$GROUP)\ncol_counts <- c(col_counts, sum(col_counts))\n\ntbl_recipe <- basic_table() %>%\n  rtables::split_cols_by(var = \"GROUP\") %>%\n  add_overall_col(\"All\") %>%\n  ## 1st-level row-wise splitting, and its column-wise analysis function\n  rtables::split_rows_by(\"level_1\", split_fun = remove_split_levels(c(NA_character_))) %>%\n  rtables::summarize_row_groups(cfun = count_items_cfun,\n                                extra_args = list(n_var = \"aval_1\", n_unique_keys = \"SUBJID\", hide_value = FALSE)) %>%\n  ## 2nd-level row-wise splitting, and its column-wise analysis function, use n_unique_keys to remove duplicated records\n  rtables::split_rows_by(\"level_2\") %>%\n  rtables::summarize_row_groups(cfun = count_items_cfun, extra_args = list(\n    n_var = \"aval_2\", N_var = \"aval_1\", N_unique_keys = \"SUBJID\",\n    n_unique_keys = c(\"SUBJID\"), empty_row = FALSE\n  )) %>%\n  ## 3rd-level row-wise splitting, and its column-wise analysis function, use n_unique_keys to remove duplicated records\n  rtables::split_rows_by(\"level_3\") %>%\n  rtables::summarize_row_groups(cfun = count_items_cfun, extra_args = list(\n    n_var = \"aval_3\", n_unique_keys = c(\"SUBJID\"), N_var = \"aval_1\", N_unique_keys = \"SUBJID\", N_index = 1,\n    empty_row = TRUE\n  ))\n\ntbl_test3 <- tbl_recipe %>%\n  rtables::build_table(df, col_counts = col_counts)\n\n\n\n\nABCAll(N=3)(N=6)(N=1)(N=10)level 12316  level 22/2 (100)2/3 (66.7)1/1 (100)5/6 (83.3)    level_30/20/31/1 (100)1/6 (16.7)"
  },
  {
    "objectID": "posts/rtables/customize_cell.html",
    "href": "posts/rtables/customize_cell.html",
    "title": "Customize the format of rcell",
    "section": "",
    "text": "library(rtables)\nlibrary(formatters)"
  },
  {
    "objectID": "posts/rtables/customize_cell.html#rcell",
    "href": "posts/rtables/customize_cell.html#rcell",
    "title": "Customize the format of rcell",
    "section": "rcell",
    "text": "rcell\nDescription\nConstruct a cell value and associate formatting, labeling, indenting, and column spanning information with it.\nUsage\n\nrcell(\nx,\nformat = NULL,\ncolspan = 1L,\nrcell 103\nlabel = NULL,\nindent_mod = NULL,\nfootnotes = NULL,\nalign = NULL,\nformat_na_str = NULL\n)\n\nArguments\n\n\n\n\n\n\n\nx\nANY. Cell value\n\n\nformat\nif FUN does not return a formatted rcell then the format is applied\n\n\n…\nfurther arguments passed to rcell\n\n\n\n\nReal case\nIf we have a calculation 1/4*100, the result 25 and the decimal is 2. the avaiable format in rtables is xx.xx\n\nrcell(\n  x = 25,\n  format = 'xx.xx'\n)\n\nrcell: 25.00 \n\n\nWhat if we want a format like 1 (25.00)? how can we customize the format in rcell as expected? Let’s go through the function of sprintf firstly. the sprintf can returns a character vector containing a formatted combination of text and variable values.\n\nprint the 25 to 25.00\n\n\nsprintf(\"%.2f\", 25)\n\n[1] \"25.00\"\n\n\nFor the given format, %: it’s like a place holder for the passed value, f: Double precision value, see more on sprintf\n\nupdate the format and passed value\n\n\nsprintf(\"%.0f %.2f\", 1, 25)\n\n[1] \"1 25.00\"\n\n\n\nsprintf(\"%.0f (%.2f)\", 1, 25)\n\n[1] \"1 (25.00)\"\n\n\n\nIn order to apply this format on other values, can we separate the formatting %.0f (%.2f) and the passed value 1 and 25?\nthere are two functions from package formatters\nsprintf_format: Specify text format\nformat_value: Converts a value into a string using the format information\n\nfmtfun <- formatters::sprintf_format(\"%.0f (%.2f)\")\n\nformat_value(x = c(1, 25),\n             format = fmtfun)\n\n[1] \"1 (25.00)\"\n\n\nAs for the rcell and its argument x and format, we can think it is a wrapper around the format_value\n\nrcell(\n  x = c(1, 25),\n  format = formatters::sprintf_format(\"%.0f (%.2f)\")\n)\n\nrcell: 1 (25.00) \n\n\nThen, we can also easily customize the result of 1/4*100 as 1/4 (25.00)\n\nrcell(\n  x = c(1, 4, 25),\n  format = formatters::sprintf_format(\"%.0f/%.0f (%.2f)\")\n)\n\nrcell: 1/4 (25.00) \n\n\n\n\nCreate format helper function\nwe can further more wrap this pair of funcions into two helper function for better usage.\n\n#' a pair of functions sprintf_format and format_values used for rcell\n#'\n#' @param n Unique number of events for the current category\n#' @param N Total number of events under the split column\n#' @param decimal Number of decimal to display\n#' @param type to decide if the denominator n/N(%) in the result\n#' @keywords sprintf_format\n#'\n#' @return\nsprintf_format_helper <- function(n, N, decimal = 1, type = \"n(%)\") {\n  showN <- NULL\n  if (type == \"n/N(%)\"){\n    showN <- \"/%.0f\"\n  }\n\n  if (n == 0) {\n    fmt <- sprintf_format(paste0(\"%.0f\", showN))\n  } else if (n == N) {\n    # if pct == 100%, then show (100) instead of (100.0)\n    fmt <- sprintf_format(paste0(\"%.0f\", showN, \" \", \"(%.0f)\"))\n  } else {\n    fmt <- sprintf_format(paste0(\"%.0f\", showN, \" (%.\", decimal, \"f)\"))\n  }\n\n  return(fmt)\n}\n\n\n#' a pair of functions sprintf_format and format_values used for rcell\n#'\n#' @param n Unique number of events for the current category\n#' @param N Total number of events under the split column\n#' @param type to decide if the denominator n/N(%) in the result\n#'\n#' @keywords format_values\n#' @example\n#' rcell(x = format_values_helper(1, 10),\n#'       format = sprintf_format_helper(1, 10))\n#'\n#' rcell(x = format_values_helper(1, 10, type = \"n/N(%)\"),\n#'       format = sprintf_format_helper(1, 10, type = \"n/N(%)\"))\n#'\n#' rcell(x = format_values_helper(10, 10),\n#'       format = sprintf_format_helper(10, 10))\n#'\n#' @return\nformat_values_helper <- function(n, N, type = \"n(%)\") {\n  showN <- NULL\n  if (type == \"n/N(%)\"){\n    showN <- N\n  }\n  if (n == 0) {\n    value <- c(0, showN)\n  } else {\n    value <- c(n, showN, n / N * 100)\n  }\n\n  return(value)\n}\n\nthen, we can apply various formatter during printing values in rcell.\n\nrcell(x = format_values_helper(1, 10),\n      format = sprintf_format_helper(1, 10))\n\nrcell: 1 (10.0) \n\n\n\nrcell(x = format_values_helper(1, 10, type = \"n/N(%)\"),\n      format = sprintf_format_helper(1, 10, type = \"n/N(%)\"))\n\nrcell: 1/10 (10.0) \n\n\n\nrcell(x = format_values_helper(10, 10),\n      format = sprintf_format_helper(10, 10))\n\nrcell: 10 (100) \n\n\n\nrcell(x = format_values_helper(0, 10, type = \"n/N(%)\"),\n      format = sprintf_format_helper(0, 10, type = \"n/N(%)\"))\n\nrcell: 0/10"
  },
  {
    "objectID": "posts/manipulate/dplyr_cross.html",
    "href": "posts/manipulate/dplyr_cross.html",
    "title": "Derive multiple columns based on across",
    "section": "",
    "text": "library(dplyr)"
  },
  {
    "objectID": "posts/manipulate/dplyr_cross.html#reale-case",
    "href": "posts/manipulate/dplyr_cross.html#reale-case",
    "title": "Derive multiple columns based on across",
    "section": "Reale Case",
    "text": "Reale Case\nSuppose we this data with columns num_var1_1, num_var1_99 and denom1_1, denom1_99\n\ntest_data <- data.frame(num_var1_1 = c(1, 4),\n                        num_var1_99 = c(2, 6),\n                        denom1_1 = c(2, 5),\n                        denom1_99 = c(3, 1))\n\nwhat we want to do is to add two new columns: the new column equal to the sum of num_var_x and denom1_y. Just fit the data into the function sum_c\n\nsum_c <- function(x, y){\n  ifelse(y > 2, x+y+10, x+y)\n}\n\ntest_data1 <- test_data %>%\n             mutate(var1_1 = sum_c(num_var1_1, denom1_1),\n                    var1_99 = sum_c(num_var1_99, denom1_99))\n\n\n\n\n\n \n  \n    num_var1_1 \n    num_var1_99 \n    denom1_1 \n    denom1_99 \n    var1_1 \n    var1_99 \n  \n \n\n  \n    1 \n    2 \n    2 \n    3 \n    3 \n    15 \n  \n  \n    4 \n    6 \n    5 \n    1 \n    19 \n    7 \n  \n\n\n\n\n\nthe code seems repetitive and not readable."
  },
  {
    "objectID": "posts/manipulate/dplyr_cross.html#dplyracross",
    "href": "posts/manipulate/dplyr_cross.html#dplyracross",
    "title": "Derive multiple columns based on across",
    "section": "dplyr::across()",
    "text": "dplyr::across()\nwe can use the across() to easily apply the functions to the selected columns.\nDescription\nacross() makes it easy to apply the same transformation to multiple columns, allowing you to use select() semantics inside in “data-masking” functions like summarise() and mutate(). See vignette(\"colwise\") for more details.\nUsage\n\nacross(.cols = everything(), .fns = NULL, ..., .names = NULL)\n\nArguments\n\n\n\n\n\n\n\n.cols\n<tidy-select> Columns to transform. You can’t select grouping columns because they are already automatically handled by the verb (i.e. summarise() or mutate()).\n\n\n.fns\nFunctions to apply to each of the selected columns. Possible values are:\n\n\n\n\nA function, e.g. mean.\nA purrr-style lambda, e.g. ~ mean(.x, na.rm = TRUE)\nA list of functions/lambdas, e.g. list(mean = mean, n_miss = ~ sum(is.na(.x))\nNULL: the default value, returns the selected columns in a data frame without applying a transformation. This is useful for when you want to use a function that takes a data frame.\n\nWithin these functions you can use cur_column() and cur_group() to access the current column and grouping keys respectively.\n.names| A glue specification that describes how to name the output columns. This can use {.col} to stand for the selected column name, and {.fn} to stand for the name of the function being applied. The default NULL is equivalent to {.col} for the single function case and {.col}_{.fn} for the case where a list is used for .fns.\n\nMethod 1\nTo use the across in this case:\n\ntest_data %>%\n  mutate(across(.cols = starts_with('num_var1'),\n                .fns = ~sum_c(., get(gsub('num_var1', \"denom1\", cur_column()))),\n                .names = \"{gsub('num_var1', 'var1', .col)}\"))\n\n\n\n\n\n \n  \n    num_var1_1 \n    num_var1_99 \n    denom1_1 \n    denom1_99 \n    var1_1 \n    var1_99 \n  \n \n\n  \n    1 \n    2 \n    2 \n    3 \n    3 \n    15 \n  \n  \n    4 \n    6 \n    5 \n    1 \n    19 \n    7 \n  \n\n\n\n\n\nSteps:\n\nselect referenced columns by starts_with('num_var1')\napply the function sum_c. here, the first argument x is from the .cols, the second argument y is retrived by using the function cur_column().\ngive the names to new columns\n\n\n\nMethod 2\nthis code will be used for a function that can do the vectorized calculation. it’s faster that the method 1.\n\ntest_data %>%\n  mutate(Vectorize(sum_c)(across(starts_with('num_var1'),\n                                 .names = \"{gsub('num_var1', 'var1', .col)}\"),\n                          across(starts_with('denom1')))) %>%\n  do.call(data.frame, .) %>%\n  rename_at(dplyr::vars(starts_with(\"Vectorize\")), ~ gsub(\"Vectorize.sum_c.......\", \"\", .))\n\n\n\n\n\n \n  \n    num_var1_1 \n    num_var1_99 \n    denom1_1 \n    denom1_99 \n    var1_1 \n    var1_99 \n  \n \n\n  \n    1 \n    2 \n    2 \n    3 \n    3 \n    15 \n  \n  \n    4 \n    6 \n    5 \n    1 \n    19 \n    7 \n  \n\n\n\n\n\nSteps:\n\nin the mutate, the function firstly is vectorized since we need a vector result returned.\nthe function sum_c take the first across() as argument x, the name of new columns is set in here. the second across() select the needed columns as argument y.\nboth passed value x, y actually are two dataframe. e.g. the first one is test_data %>% select(starts_with('num_var1')), the second one is test_data %>% select(starts_with('denom1')). to accept the dataframe value, the sum_c need to be a vectorized function.\nthe mutate return a matrix as the new column, which can be transformed by data.frame(as.data.frame not work)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "One Day",
    "section": "",
    "text": "Nice to meet you"
  },
  {
    "objectID": "archive.html",
    "href": "archive.html",
    "title": "Archive",
    "section": "",
    "text": "Mutiple level calculation 4\n\n\n\n\n\n\n\n\n\nApr 11, 2023\n\n\n\n\n\n\n\n\nMutiple level calculation 3\n\n\n\n\n\n\n\n\n\nApr 10, 2023\n\n\n\n\n\n\n\n\nMutiple level calculation 2\n\n\n\n\n\n\n\n\n\nApr 9, 2023\n\n\n\n\n\n\n\n\nDerive multiple columns based on across\n\n\n\n\n\n\n\n\n\nApr 8, 2023\n\n\n\n\n\n\n\n\nMutiple level calculation 1\n\n\n\n\n\n\n\n\n\nApr 7, 2023\n\n\n\n\n\n\n\n\nCustomize the format of rcell\n\n\n\n\n\n\n\n\n\nApr 6, 2023\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "manipulate-series.html",
    "href": "manipulate-series.html",
    "title": "Series: manipulate data",
    "section": "",
    "text": "Derive multiple columns based on across\n\n\n\n\n\nWhen we want to add new columns and have to iterate…\n\n\n\n\n\n\nApr 8, 2023\n\n\n4 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "rtables-series.html",
    "href": "rtables-series.html",
    "title": "Series: rtables",
    "section": "",
    "text": "Mutiple level calculation 4\n\n\n\n\n\nmultiple level counts more than 2 levels\n\n\n\n\n\n\nApr 11, 2023\n\n\n7 min\n\n\n\n\n\n\n\n\nMutiple level calculation 3\n\n\n\n\n\nsummary counts by summarize_row_groups\n\n\n\n\n\n\nApr 10, 2023\n\n\n13 min\n\n\n\n\n\n\n\n\nMutiple level calculation 2\n\n\n\n\n\nWrap the analysis function\n\n\n\n\n\n\nApr 9, 2023\n\n\n13 min\n\n\n\n\n\n\n\n\nMutiple level calculation 1\n\n\n\n\n\nExplore how to handle the mutiple calculation by rtables\n\n\n\n\n\n\nApr 7, 2023\n\n\n14 min\n\n\n\n\n\n\n\n\nCustomize the format of rcell\n\n\n\n\n\nConstruct a cell value and associate formatting\n\n\n\n\n\n\nApr 6, 2023\n\n\n3 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "One Day",
    "section": "",
    "text": "Series\n\nrtables-series\nThis series contains a great deal of tips, tricks and packages that you can use to level up your rtables game.\n\n\nmanipulate-series\nThis series contains a great deal of tips, tricks of dplyr\n\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nMutiple level calculation 4\n\n\n\n\n\n\n\nR\n\n\nrtables\n\n\n\n\nmultiple level counts more than 2 levels\n\n\n\n\n\n\nApr 11, 2023\n\n\n7 min\n\n\n\n\n\n\n\n\nMutiple level calculation 3\n\n\n\n\n\n\n\nR\n\n\nrtables\n\n\n\n\nsummary counts by summarize_row_groups\n\n\n\n\n\n\nApr 10, 2023\n\n\n13 min\n\n\n\n\n\n\n\n\nMutiple level calculation 2\n\n\n\n\n\n\n\nR\n\n\nrtables\n\n\n\n\nWrap the analysis function\n\n\n\n\n\n\nApr 9, 2023\n\n\n13 min\n\n\n\n\n\n\n\n\nDerive multiple columns based on across\n\n\n\n\n\n\n\nR\n\n\ndplyr\n\n\nacross\n\n\n\n\nWhen we want to add new columns and have to iterate…\n\n\n\n\n\n\nApr 8, 2023\n\n\n4 min\n\n\n\n\n\n\n\n\nMutiple level calculation 1\n\n\n\n\n\n\n\nR\n\n\nrtables\n\n\n\n\nExplore how to handle the mutiple calculation by rtables\n\n\n\n\n\n\nApr 7, 2023\n\n\n14 min\n\n\n\n\n\n\n\n\nCustomize the format of rcell\n\n\n\n\n\n\n\nR\n\n\nrtables\n\n\n\n\nConstruct a cell value and associate formatting\n\n\n\n\n\n\nApr 6, 2023\n\n\n3 min\n\n\n\n\n\n\nNo matching items"
  }
]
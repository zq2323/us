[
  {
    "objectID": "archive.html",
    "href": "archive.html",
    "title": "Archive",
    "section": "",
    "text": "Draft TLF generator\n\n\n\n\n\n\n\n\n\nApr 25, 2023\n\n\n\n\n\n\n\n\nDerive new columns based on given formula\n\n\n\n\n\n\n\n\n\nApr 16, 2023\n\n\n\n\n\n\n\n\nMutiple level calculation 4\n\n\n\n\n\n\n\n\n\nApr 11, 2023\n\n\n\n\n\n\n\n\nMutiple level calculation 3\n\n\n\n\n\n\n\n\n\nApr 10, 2023\n\n\n\n\n\n\n\n\nMutiple level calculation 2\n\n\n\n\n\n\n\n\n\nApr 9, 2023\n\n\n\n\n\n\n\n\nDerive multiple columns based on across\n\n\n\n\n\n\n\n\n\nApr 8, 2023\n\n\n\n\n\n\n\n\nMutiple level calculation 1\n\n\n\n\n\n\n\n\n\nApr 7, 2023\n\n\n\n\n\n\n\n\nCustomize the format of rcell\n\n\n\n\n\n\n\n\n\nApr 6, 2023\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "manipulate-series.html",
    "href": "manipulate-series.html",
    "title": "Series: manipulate data",
    "section": "",
    "text": "Draft TLF generator\n\n\n\n\n\nDraft the TLF generator tool\n\n\n\n\n\n\nApr 25, 2023\n\n\n19 min\n\n\n\n\n\n\n\n\nDerive new columns based on given formula\n\n\n\n\n\nEfficiently Derive new columns based on formula\n\n\n\n\n\n\nApr 16, 2023\n\n\n5 min\n\n\n\n\n\n\n\n\nDerive multiple columns based on across\n\n\n\n\n\nWhen we want to add new columns and have to iterate…\n\n\n\n\n\n\nApr 8, 2023\n\n\n5 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_1.html",
    "href": "posts/rtables/multiple_levels_calculation_1.html",
    "title": "Mutiple level calculation 1",
    "section": "",
    "text": "library(rtables)\nlibrary(formatters)\nlibrary(dplyr)"
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_1.html#multiple-lelvels-calculation",
    "href": "posts/rtables/multiple_levels_calculation_1.html#multiple-lelvels-calculation",
    "title": "Mutiple level calculation 1",
    "section": "Multiple lelvels calculation",
    "text": "Multiple lelvels calculation\nMultipile levels calculation for categorical variable is the most common cases in Table, e.g. PCSA, Exposure tables.\nIn this section, we will explore how to produce these output in rtables.\nBelow is the test data:\n\ndf &lt;- data.frame(SUBJID = c(rep('S1', 5), rep(\"S2\", 4), rep(\"S3\", 2)),\n                 ASEQ = c(1:5, 1:4, 1:2),\n                 GROUP = factor(c(rep('A', 5), rep(\"B\", 4), rep('A', 2)), levels = c(\"A\", \"B\")),\n                 PARAMCD = c('TEST_1', 'TEST_1', 'TEST_1', 'TEST_1', 'TEST_2', 'TEST_1', 'TEST_1', 'TEST_2', 'TEST_2', 'TEST_1', 'TEST_2'),\n                 CRIT = c('LEVEL_2_1','LEVEL_2_1', 'LEVEL_2_2', NA_character_, 'LEVEL_2_a', 'LEVEL_2_1', NA_character_, 'LEVEL_2_a', 'LEVEL_2_b', NA_character_, 'LEVEL_2_b'))\n\n\n\n\n\n\nSUBJID\nASEQ\nGROUP\nPARAMCD\nCRIT\n\n\n\n\nS1\n1\nA\nTEST_1\nLEVEL_2_1\n\n\nS1\n2\nA\nTEST_1\nLEVEL_2_1\n\n\nS1\n3\nA\nTEST_1\nLEVEL_2_2\n\n\nS1\n4\nA\nTEST_1\nNA\n\n\nS1\n5\nA\nTEST_2\nLEVEL_2_a\n\n\nS2\n1\nB\nTEST_1\nLEVEL_2_1\n\n\nS2\n2\nB\nTEST_1\nNA\n\n\nS2\n3\nB\nTEST_2\nLEVEL_2_a\n\n\nS2\n4\nB\nTEST_2\nLEVEL_2_b\n\n\nS3\n1\nA\nTEST_1\nNA\n\n\nS3\n2\nA\nTEST_2\nLEVEL_2_b\n\n\n\n\n\n\n\nNow, we need to take the PARAMCD as 1st level, and the CRIT as 2nd level to calculate the frequency of each TEST, it will be a table like PCSA."
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_4.html",
    "href": "posts/rtables/multiple_levels_calculation_4.html",
    "title": "Mutiple level calculation 4",
    "section": "",
    "text": "library(rtables)\nlibrary(formatters)\nlibrary(dplyr)\nlibrary(stringr)"
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_4.html#summary-counts-more-than-2rd-level",
    "href": "posts/rtables/multiple_levels_calculation_4.html#summary-counts-more-than-2rd-level",
    "title": "Mutiple level calculation 4",
    "section": "Summary counts more than 2rd level",
    "text": "Summary counts more than 2rd level\n\n\n\n\n\nSUBJID\nGROUP\nAVAL\nlevel_1\nlevel_2\nlevel_3\naval_1\naval_2\naval_3\n\n\n\n\nS1\nA\n2\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nS2\nC\n19\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nS3\nC\n3\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nS4\nA\n14\nlevel 1\nlevel 2\nNA\n1\n1\nNA\n\n\nS5\nB\n5\nlevel 1\nNA\nNA\n1\nNA\nNA\n\n\nS6\nC\n7\nlevel 1\nlevel 2\nNA\n1\n1\nNA\n\n\nS7\nB\n8\nlevel 1\nlevel 2\nNA\n1\n1\nNA\n\n\nS8\nA\n20\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nS9\nA\n13\nlevel 1\nlevel 2\nNA\n1\n1\nNA\n\n\nS10\nC\n11\nlevel 1\nlevel 2\nlevel_3\n1\n1\n1\n\n\n\n\n\n\n\n\ncol_counts &lt;- table(df$GROUP)\ncol_counts &lt;- c(col_counts, sum(col_counts))\n\ntbl_recipe &lt;- basic_table() %&gt;%\n  rtables::split_cols_by(var = \"GROUP\") %&gt;%\n  add_overall_col(\"All\") %&gt;%\n  ## 1st-level row-wise splitting, and its column-wise analysis function\n  rtables::split_rows_by(\"level_1\", split_fun = remove_split_levels(c(NA_character_))) %&gt;%\n  rtables::summarize_row_groups(cfun = count_items_cfun,\n                                extra_args = list(n_var = \"aval_1\", n_unique_keys = \"SUBJID\", hide_value = FALSE)) %&gt;%\n  ## 2nd-level row-wise splitting, and its column-wise analysis function, use n_unique_keys to remove duplicated records\n  rtables::split_rows_by(\"level_2\") %&gt;%\n  rtables::summarize_row_groups(cfun = count_items_cfun, extra_args = list(\n    n_var = \"aval_2\", N_var = \"aval_1\", N_unique_keys = \"SUBJID\",\n    n_unique_keys = c(\"SUBJID\"), empty_row = FALSE\n  )) %&gt;%\n  ## 3rd-level row-wise splitting, and its column-wise analysis function, use n_unique_keys to remove duplicated records\n  rtables::split_rows_by(\"level_3\") %&gt;%\n  rtables::summarize_row_groups(cfun = count_items_cfun, extra_args = list(\n    n_var = \"aval_3\", n_unique_keys = c(\"SUBJID\"), N_var = \"aval_1\", N_unique_keys = \"SUBJID\", N_index = 1,\n    empty_row = TRUE\n  ))\n\ntbl_test3 &lt;- tbl_recipe %&gt;%\n  rtables::build_table(df, col_counts = col_counts)\n\n\n\n\nABCAll(N=4)(N=2)(N=4)(N=10)level 12226  level 22/2 (100)1/2 (50.0)2/2 (100)5/6 (83.3)    level_30/20/21/2 (50.0)1/6 (16.7)"
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_2.html",
    "href": "posts/rtables/multiple_levels_calculation_2.html",
    "title": "Mutiple level calculation 2",
    "section": "",
    "text": "library(rtables)\nlibrary(formatters)\nlibrary(dplyr)"
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_2.html#wrap-the-analysis-function",
    "href": "posts/rtables/multiple_levels_calculation_2.html#wrap-the-analysis-function",
    "title": "Mutiple level calculation 2",
    "section": "Wrap the analysis function",
    "text": "Wrap the analysis function\nThe function is too long and it’s not convient mixed with the layout of rtbales. For better user experience, we can create a function summarise_vars_categorical\n\nwrap the analysis function as summarise_vars_categorical_afun\nwrap the summarise_vars_categorical_afun and the extral_args within the summarise_vars_categorical\n\nThen user can passed all the analysis variables and customized argument by a single function summarise_vars_categorical.\n\n# wrap the analysis function\nsummarise_vars_categorical_afun &lt;- function(df, .N_col, .var, .N_row,\n                                            format = 'n(%)',\n                                            decimal = 1,\n                                            n_unique_keys = NULL,\n                                            N_unique_keys = NULL,\n                                            show_N_item = FALSE,\n                                            add_Number = FALSE,\n                                            missing_rm = TRUE,\n                                            missing_label = NULL,\n                                            indent_mod = 0L,\n                                            ...) {\n\n\n  if(missing_rm){\n    df &lt;- df %&gt;% filter(!(!!as.name(.var) %in% \"Missing_value_flag\"))\n  }\n\n  df_n &lt;- df\n  if(!is.null(n_unique_keys)){\n    df_n &lt;- df %&gt;% distinct(across(c(n_unique_keys, .var)), .keep_all = TRUE)\n  }\n  x &lt;- df_n[[.var]]\n  if(!is.null(N_unique_keys)){\n    cus_N_col &lt;- df %&gt;% distinct(across(N_unique_keys)) %&gt;% nrow()\n  }else{\n    cus_N_col &lt;- .N_col\n  }\n\n  lst_body &lt;- lapply(\n    as.list(table(x)),\n    function(xi) {\n      rcell(format_values_helper(xi, cus_N_col, type = format),\n            format = sprintf_format_helper(xi, cus_N_col, 1, type = format),\n            indent_mod = indent_mod\n      )\n    }\n  )\n  if(add_Number){\n    lst_body &lt;- append(setNames(list(rcell(cus_N_col,\n                                           format = \"xx\",\n                                           indent_mod = indent_mod)), 'Number'), lst_body)\n  }\n\n  if(is.null(missing_label)){\n    if(\"Missing_value_flag\" %in% names(lst_body)){\n      lst_body &lt;- purrr::list_modify(lst_body, \"Missing_value_flag\" = NULL)\n    }\n  }else{\n    lst_body &lt;- lst_body %&gt;%\n      setNames(gsub(\"Missing_value_flag\", missing_label, names(.)))\n\n  }\n\n  in_rows(\n    .list = c(\n      lst_body,\n      # add empty row, in .list obj\n      \" \" = rcell(\"\", format = \"xx\")\n    )\n  )\n}\n\n# wrap the summarise_vars_categorical_afun and the extral_args\nsummarise_vars_categorical &lt;- function(lyt,\n                                       vars,\n                                       var_labels,\n                                       format = 'n(%)',\n                                       decimal = 1,\n                                       n_unique_keys = NULL,\n                                       N_unique_keys = NULL,\n                                       show_N_item = FALSE,\n                                       add_Number = FALSE,\n                                       missing_rm = TRUE,\n                                       missing_label = NULL,\n                                       show_labels='visible',\n                                       indent_mod = 0L, ...){\n  rtables::analyze(lyt, vars, var_labels,\n                   afun = summarise_vars_categorical_afun,\n                   extra_args = list(format = format,\n                                     decimal = decimal,\n                                     n_unique_keys = n_unique_keys,\n                                     N_unique_keys = N_unique_keys,\n                                     show_N_item = show_N_item,\n                                     add_Number = add_Number,\n                                     missing_rm = missing_rm,\n                                     missing_label = missing_label),\n                   show_labels = show_labels, indent_mod = indent_mod)\n}\n\n\nlyt &lt;- basic_table() %&gt;%\n  split_cols_by(\"GROUP\") %&gt;%\n  add_overall_col(\"All\") %&gt;%\n  summarise_vars_categorical(vars = c('TEST_1_fmt', 'TEST_2_fmt'),\n                             var_labels = c('This is test 1', 'This is test 2'),\n                             format = 'n/N(%)',\n                             n_unique_keys = c(\"SUBJID\"),\n                             N_unique_keys = c(\"SUBJID\"),\n                             add_Number = TRUE,\n                             missing_rm = FALSE\n\n  )\n\ntbl &lt;- lyt %&gt;% rtables::build_table(df1, col_counts = col_counts)\n\n\n\n\nABAll(N=2)(N=1)(N=3)This is test 1  Number213  1 of level 21/2 (50.0)1/1 (100)2/3 (66.7)  2 of level 21/2 (50.0)0/11/3 (33.3)  3 of level 20/20/10/3  Missing_value_flag   This is test 2  Number213  a of level 21/2 (50.0)1/1 (100)2/3 (66.7)  b of level 21/2 (50.0)1/1 (100)2/3 (66.7)  c of level 20/20/10/3  Missing_value_flag"
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_3.html",
    "href": "posts/rtables/multiple_levels_calculation_3.html",
    "title": "Mutiple level calculation 3",
    "section": "",
    "text": "library(rtables)\nlibrary(formatters)\nlibrary(dplyr)\nlibrary(stringr)"
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_3.html#method-2",
    "href": "posts/rtables/multiple_levels_calculation_3.html#method-2",
    "title": "Mutiple level calculation 3",
    "section": "Method 2",
    "text": "Method 2\nAnother powerful function rtables provide to us is the function summarize_row_groups, which can be used to add a content row of summary counts.\nThis function need a different data structure from the rtable::analyze(). rtable::analyze() is kind of the columns-based analysis, the summarize_row_groups is more like the rows-based analysis.\nTo build the data:\n\ncreate the 1st level columns by PARAMCD, TEST_1_level_1, TEST_2_level_1\nCreate the 2rd level columns by CRIT, TEST_1_level_2, TEST_2_level_2\n\n\nparam_coding &lt;- c('TEST_1' = 'This is test 1',\n                  'TEST_2' = 'This is test 2')\ndf &lt;- df %&gt;% mutate(PARAML = param_coding[PARAMCD])\ntmp &lt;- df\ntmp[, str_c(names(param_coding), '_level_1')] &lt;- NA_character_\n\n\n# tmp1 &lt;- df %&gt;% mutate(TEST_1_level_1 = ifelse(PARAMCD == 'TEST_1', PARAMCD, NA_character_),\n#                       TEST_2_level_1 = ifelse(PARAMCD == 'TEST_2', PARAMCD, NA_character_),\n#                       TEST_1_aval_1 = ifelse(!is.na(TEST_1_level_1), 1, NA_character_),\n#                       TEST_1_aval_1 = ifelse(!is.na(TEST_2_level_1), 1, NA_character_),\n#                       TEST_1_level_2 = ifelse(PARAMCD == 'TEST_1' & !is.na(CRIT), CRIT, NA_character_),\n#                       TEST_2_level_2 = ifelse(PARAMCD == 'TEST_2' & !is.na(CRIT), CRIT, NA_character_),\n#                       TEST_1_aval_2 = ifelse(!is.na(TEST_1_level_2), 1, NA_character_),\n#                       TEST_2_aval_2 = ifelse(!is.na(TEST_2_level_2), 1, NA_character_)\n#                       )\n\ntmp1 &lt;- tmp %&gt;%\n  mutate(\n    across(\n      .cols = c(\"TEST_1_level_1\", \"TEST_2_level_1\"),\n      .fns = \\(x)  factor(ifelse(grepl(gsub(\"_level_1\", \"\",cur_column()), PARAMCD), PARAML, x))\n    )\n    ,\n    across(c(do.call(str_c, expand.grid(names(param_coding), c('_level_1')))),\n           ~ifelse(!is.na(.x), 1, .x),\n           .names = \"{gsub('level','aval', .col)}\")\n    )\n\n\ntmp1[, str_c(names(param_coding), '_level_2')] &lt;- NA_character_\n\n\nfmt &lt;- list(\n  'TEST_1_level_2' = c('LEVEL_2_1' = '1 of level 2',\n               'LEVEL_2_2' = '2 of level 2',\n               'LEVEL_2_3' = '3 of level 2'),\n  \"TEST_2_level_2\" = c('LEVEL_2_a' = 'a of level 2',\n               'LEVEL_2_b' = 'b of level 2',\n               'LEVEL_2_c' = 'c of level 2')\n)\n\ntmp2 &lt;- tmp1 %&gt;%\n  mutate(\n    across(\n      .cols = c(\"TEST_1_level_2\", \"TEST_2_level_2\"),\n      .fns = \\(x)  factor(ifelse(grepl(gsub(\"_level_2\", \"\",cur_column()), PARAMCD) & !is.na(CRIT) , fmt[[cur_column()]][CRIT], x), levels = fmt[[cur_column()]])\n    ),\n    across(c(do.call(str_c, expand.grid(names(param_coding), c('_level_2')))),\n           ~ifelse(!is.na(.x), 1, .x),\n           .names = \"{gsub('level','aval', .col)}\")\n  )"
  },
  {
    "objectID": "posts/rtables/multiple_levels_calculation_3.html#wrap-the-analysis-function",
    "href": "posts/rtables/multiple_levels_calculation_3.html#wrap-the-analysis-function",
    "title": "Mutiple level calculation 3",
    "section": "Wrap the analysis function",
    "text": "Wrap the analysis function\n\ntbl_recipe &lt;- basic_table() %&gt;%\n  rtables::split_cols_by(var = \"GROUP\") %&gt;%\n  add_overall_col(\"All\") %&gt;%\n  ## 1st-level row-wise splitting, and its column-wise analysis function\n  rtables::split_rows_by(\"TEST_1_level_1\", split_fun = remove_split_levels(c(NA_character_))) %&gt;%\n  rtables::summarize_row_groups(cfun = count_items_cfun,\n                                extra_args = list(n_var = \"TEST_1_aval_1\", n_unique_keys = \"SUBJID\", hide_value = TRUE)) %&gt;%\n  ## 2nd-level row-wise splitting, and its column-wise analysis function, use n_unique_keys to remove duplicated records\n  rtables::split_rows_by(\"TEST_1_level_2\") %&gt;%\n  rtables::summarize_row_groups(cfun = count_items_cfun, extra_args = list(\n    n_var = \"TEST_1_aval_2\", n_unique_keys = c(\"SUBJID\"), N_var = \"TEST_1_aval_1\", N_unique_keys = \"SUBJID\",\n    empty_row = TRUE\n  ))\n\ncol_counts_df &lt;- tmp2 %&gt;%\n  distinct(SUBJID, GROUP)\ncol_counts &lt;- table(col_counts_df$GROUP)\ncol_counts &lt;- c(col_counts, sum(col_counts))\ntest1_tbl &lt;- tbl_recipe %&gt;%\n  rtables::build_table(tmp2, col_counts = col_counts)\n\n\n\n\nABAll(N=2)(N=1)(N=3)This is test 1  1 of level 21/2 (50.0)1/1 (100)2/3 (66.7)  2 of level 21/2 (50.0)0/11/3 (33.3)  3 of level 20/20/10/3   \n\n\n\ncount_items_cfun &lt;- function(df,\n                        labelstr,\n                        .spl_context,\n                        n_var,\n                        n_unique_keys = NULL,\n                        N_var = NULL,\n                        N_index = NULL,\n                        N_unique_keys = NULL,\n                        empty_row = FALSE,\n                        hide_value = FALSE,\n                        format = \"n/N(%)\") {\n\n  # caculate the value\n  df_n &lt;- df\n  if (!is.null(n_unique_keys)) {\n    df_n &lt;- df %&gt;% distinct(across(n_unique_keys), .keep_all = T)\n  }\n  x &lt;- df_n[[n_var]]\n  n &lt;- sum(x[!is.na(x)])\n\n  cur_index &lt;- which(.spl_context[[\"value\"]] == labelstr)\n  # View(df)\n  if (!is.null(N_var)) {\n\n    # get N of parent for denomitor caculation\n    if (!is.null(N_index)) {\n      parent_df &lt;- .spl_context$full_parent_df[[N_index]][.spl_context[[\"cur_col_subset\"]][[N_index]], ]\n    } else {\n      parent_df &lt;- .spl_context$full_parent_df[[cur_index - 1]][.spl_context[[\"cur_col_subset\"]][[cur_index - 1]], ]\n    }\n\n    if (!is.null(N_unique_keys)) {\n      parent_df &lt;-  parent_df %&gt;% distinct(across(N_unique_keys), .keep_all = T)\n    }\n\n    parent_x &lt;- parent_df[[N_var]]\n    parent_N &lt;- sum(!is.na(parent_x[!is.na(parent_x)]))\n\n    # get current value to check if it match the last value of levels, for empty row\n    # !Start\n    var_levels &lt;- length(.spl_context$split)\n    curr_var_level_val &lt;- .spl_context$value[[nrow(.spl_context)]]\n    last_var_level_val &lt;-\n      .spl_context$full_parent_df[[nrow(.spl_context)]][[.spl_context$split[var_levels]]] %&gt;%\n      levels() %&gt;%\n      tail(1)\n    if (curr_var_level_val == last_var_level_val & empty_row) {\n      ret &lt;- in_rows(\n        .names = c(labelstr, \" \"),\n        .list = list(c(format_values_helper(n, parent_N, type = format)), NULL),\n        .formats = c(sprintf_format_helper(n, parent_N, type = format), \"xx\")\n      )\n    } else {\n      rc &lt;- rcell(\n        x = format_values_helper(n, parent_N, type = format),\n        format = sprintf_format_helper(n, parent_N, type = format)\n      )\n      ret &lt;- in_rows(.names = labelstr, rc)\n    }\n    # !End\n  } else {\n    rc &lt;- rcell(\n      x = ifelse(hide_value, \"\", n),\n      format = \"xx\"\n    )\n    ret &lt;- in_rows(.names = labelstr, rc)\n  }\n  return(ret)\n}\n\n\n\n\ntbl_recipe &lt;- basic_table() %&gt;%\n  rtables::split_cols_by(var = \"GROUP\") %&gt;%\n  add_overall_col(\"All\") %&gt;%\n  ## 1st-level row-wise splitting, and its column-wise analysis function\n  rtables::split_rows_by(\"TEST_2_level_1\", split_fun = remove_split_levels(c(NA_character_))) %&gt;%\n  rtables::summarize_row_groups(cfun = count_items_cfun,\n                                extra_args = list(n_var = \"TEST_2_aval_1\", n_unique_keys = \"SUBJID\", hide_value = TRUE)) %&gt;%\n  ## 2nd-level row-wise splitting, and its column-wise analysis function, use n_unique_keys to remove duplicated records\n  rtables::split_rows_by(\"TEST_2_level_2\") %&gt;%\n  rtables::summarize_row_groups(cfun = count_items_cfun, extra_args = list(\n    n_var = \"TEST_2_aval_2\", n_unique_keys = c(\"SUBJID\"), N_var = \"TEST_2_aval_1\", N_unique_keys = \"SUBJID\",\n    empty_row = TRUE\n  ))\n\n\ntest2_tbl &lt;- tbl_recipe %&gt;%\n  rtables::build_table(tmp2, col_counts = col_counts)\n\n\n\n\nABAll(N=2)(N=1)(N=3)This is test 2  a of level 21/2 (50.0)1/1 (100)2/3 (66.7)  b of level 21/2 (50.0)1/1 (100)2/3 (66.7)  c of level 20/20/10/3   \n\n\n\ntbl2 &lt;- rbind(test1_tbl, test2_tbl)\n\n\n\n\nABAll(N=2)(N=1)(N=3)This is test 1  1 of level 21/2 (50.0)1/1 (100)2/3 (66.7)  2 of level 21/2 (50.0)0/11/3 (33.3)  3 of level 20/20/10/3   This is test 2  a of level 21/2 (50.0)1/1 (100)2/3 (66.7)  b of level 21/2 (50.0)1/1 (100)2/3 (66.7)  c of level 20/20/10/3"
  },
  {
    "objectID": "posts/rtables/customize_cell.html",
    "href": "posts/rtables/customize_cell.html",
    "title": "Customize the format of rcell",
    "section": "",
    "text": "library(rtables)\nlibrary(formatters)"
  },
  {
    "objectID": "posts/rtables/customize_cell.html#rcell",
    "href": "posts/rtables/customize_cell.html#rcell",
    "title": "Customize the format of rcell",
    "section": "rcell",
    "text": "rcell\nDescription\nConstruct a cell value and associate formatting, labeling, indenting, and column spanning information with it.\nUsage\n\nrcell(\nx,\nformat = NULL,\ncolspan = 1L,\nlabel = NULL,\nindent_mod = NULL,\nfootnotes = NULL,\nalign = NULL,\nformat_na_str = NULL\n)\n\nArguments\n\n\n\n\n\n\n\nx\nANY. Cell value\n\n\nformat\nif FUN does not return a formatted rcell then the format is applied\n\n\n…\nfurther arguments passed to rcell\n\n\n\n\nReal case\nIf we have a calculation 1/4*100, the result 25 and the decimal is 2. the avaiable format in rtables is xx.xx\n\nrcell(\n  x = 25,\n  format = 'xx.xx'\n)\n\nrcell: 25.00 \n\n\nWhat if we want a format like 1 (25.00)? how can we customize the format in rcell as expected? Let’s go through the function of sprintf firstly. the sprintf can returns a character vector containing a formatted combination of text and variable values.\n\nprint the 25 to 25.00\n\n\nsprintf(\"%.2f\", 25)\n\n[1] \"25.00\"\n\n\nFor the given format, %: it’s like a place holder for the passed value, f: Double precision value, see more on sprintf\n\nupdate the format and passed value\n\n\nsprintf(\"%.0f %.2f\", 1, 25)\n\n[1] \"1 25.00\"\n\n\n\nsprintf(\"%.0f (%.2f)\", 1, 25)\n\n[1] \"1 (25.00)\"\n\n\n\nIn order to apply this format on other values, can we separate the formatting %.0f (%.2f) and the passed value 1 and 25?\nthere are two functions from package formatters\nsprintf_format: Specify text format\nformat_value: Converts a value into a string using the format information\n\nfmtfun &lt;- formatters::sprintf_format(\"%.0f (%.2f)\")\n\nformat_value(x = c(1, 25),\n             format = fmtfun)\n\n[1] \"1 (25.00)\"\n\n\nAs for the rcell and its argument x and format, we can think it is a wrapper around the format_value\n\nrcell(\n  x = c(1, 25),\n  format = formatters::sprintf_format(\"%.0f (%.2f)\")\n)\n\nrcell: 1 (25.00) \n\n\nThen, we can also easily customize the result of 1/4*100 as 1/4 (25.00)\n\nrcell(\n  x = c(1, 4, 25),\n  format = formatters::sprintf_format(\"%.0f/%.0f (%.2f)\")\n)\n\nrcell: 1/4 (25.00) \n\n\n\n\nCreate format helper function\nwe can further more wrap this pair of funcions into two helper function for better usage.\n\n#' a pair of functions sprintf_format and format_values used for rcell\n#'\n#' @param n Unique number of events for the current category\n#' @param N Total number of events under the split column\n#' @param decimal Number of decimal to display\n#' @param type to decide if the denominator n/N(%) in the result\n#' @keywords sprintf_format\n#'\n#' @return\nsprintf_format_helper &lt;- function(n, N, decimal = 1, type = \"n(%)\") {\n  showN &lt;- NULL\n  if (type == \"n/N(%)\"){\n    showN &lt;- \"/%.0f\"\n  }\n\n  if (n == 0) {\n    fmt &lt;- sprintf_format(paste0(\"%.0f\", showN))\n  } else if (n == N) {\n    # if pct == 100%, then show (100) instead of (100.0)\n    fmt &lt;- sprintf_format(paste0(\"%.0f\", showN, \" \", \"(%.0f)\"))\n  } else {\n    fmt &lt;- sprintf_format(paste0(\"%.0f\", showN, \" (%.\", decimal, \"f)\"))\n  }\n\n  return(fmt)\n}\n\n\n#' a pair of functions sprintf_format and format_values used for rcell\n#'\n#' @param n Unique number of events for the current category\n#' @param N Total number of events under the split column\n#' @param type to decide if the denominator n/N(%) in the result\n#'\n#' @keywords format_values\n#' @example\n#' rcell(x = format_values_helper(1, 10),\n#'       format = sprintf_format_helper(1, 10))\n#'\n#' rcell(x = format_values_helper(1, 10, type = \"n/N(%)\"),\n#'       format = sprintf_format_helper(1, 10, type = \"n/N(%)\"))\n#'\n#' rcell(x = format_values_helper(10, 10),\n#'       format = sprintf_format_helper(10, 10))\n#'\n#' @return\nformat_values_helper &lt;- function(n, N, type = \"n(%)\") {\n  showN &lt;- NULL\n  if (type == \"n/N(%)\"){\n    showN &lt;- N\n  }\n  if (n == 0) {\n    value &lt;- c(0, showN)\n  } else {\n    value &lt;- c(n, showN, n / N * 100)\n  }\n\n  return(value)\n}\n\nthen, we can apply various formatter during printing values in rcell.\n\nrcell(x = format_values_helper(1, 10),\n      format = sprintf_format_helper(1, 10))\n\nrcell: 1 (10.0) \n\n\n\nrcell(x = format_values_helper(1, 10, type = \"n/N(%)\"),\n      format = sprintf_format_helper(1, 10, type = \"n/N(%)\"))\n\nrcell: 1/10 (10.0) \n\n\n\nrcell(x = format_values_helper(10, 10),\n      format = sprintf_format_helper(10, 10))\n\nrcell: 10 (100) \n\n\n\nrcell(x = format_values_helper(0, 10, type = \"n/N(%)\"),\n      format = sprintf_format_helper(0, 10, type = \"n/N(%)\"))\n\nrcell: 0/10"
  },
  {
    "objectID": "posts/manipulate/formula_derive.html",
    "href": "posts/manipulate/formula_derive.html",
    "title": "Derive new columns based on given formula",
    "section": "",
    "text": "library(dplyr)\nlibrary(glue)"
  },
  {
    "objectID": "posts/manipulate/formula_derive.html#real-case",
    "href": "posts/manipulate/formula_derive.html#real-case",
    "title": "Derive new columns based on given formula",
    "section": "Real Case",
    "text": "Real Case\nIt is the most common case in the data manipulation that deriving a column based on a given formula, such as Toxicity Grade variables, and PCSA variables.\n\ndf &lt;- data.frame(SUBJID = paste0(\"S\", 1:10),\n                 GROUP = factor(sample(c(\"A\", \"B\", \"C\"), 10, replace = T), levels = c(\"A\", \"B\", \"C\")),\n                 AVAL = sample.int(20, 10)\n)\n\nIf we need to create new variables based on AVAL variable and condition or criteria, we have to do the following derivation.\n\ndf &lt;- df %&gt;% mutate(level_1 = ifelse(AVAL&gt;3 & GROUP == \"A\", \"level 1\", NA_character_),\n                    level_2 = ifelse(AVAL&lt;3, \"level 2\", NA_character_))\n\n\n\n\n\n\nSUBJID\nGROUP\nAVAL\nlevel_1\nlevel_2\n\n\n\n\nS1\nB\n18\nNA\nNA\n\n\nS2\nB\n19\nNA\nNA\n\n\nS3\nA\n11\nlevel 1\nNA\n\n\nS4\nB\n1\nNA\nlevel 2\n\n\nS5\nA\n12\nlevel 1\nNA\n\n\nS6\nA\n17\nlevel 1\nNA\n\n\nS7\nB\n9\nNA\nNA\n\n\nS8\nC\n7\nNA\nNA\n\n\nS9\nA\n4\nlevel 1\nNA\n\n\nS10\nB\n5\nNA\nNA\n\n\n\n\n\n\n\nwe used the ifelse or case_when to implement the new variables.In real case, the massive new variables and conditions lead to a not easy life! here, we can develop functions for functional programming purpose to handle this kind of task."
  },
  {
    "objectID": "posts/manipulate/formula_derive.html#method-1",
    "href": "posts/manipulate/formula_derive.html#method-1",
    "title": "Derive new columns based on given formula",
    "section": "Method 1",
    "text": "Method 1\nwe store the column names, formula, and value in a list derived_rule.\n\nderived_rule &lt;- list('level_1_new' = list('formula' = 'AVAL&gt;3 & GROUP == \"A\"', value = \"level 1\"),\n                'level_2_new' = list('formula' = 'AVAL&lt;3', value = \"level 2\"))\n\nwe can combine the glue to build a function based on the given formula, and then make use of the do.call acheive our goal.\n\n1. convert formula to a function\n\nconvert_to_function &lt;- function(formula, value = NULL) {\n  args &lt;- paste(all.vars(rlang::parse_expr(formula)), collapse = \", \")\n  args &lt;- paste0(args, \", value = NULL\")\n  glue::glue(\n    \"function({args}) {{\n        if(is.null(value)){{\n            {formula}\n        }}else{{\n          ifelse({formula}, value, NA)\n        }}\n      }}\"\n  )\n}\n\nthe involved columns in the formula will be used as the arguments in the new function.\n\n\n2.Build list with functions and arguments and label value\n\nderived_column_functions &lt;- function(formula, value = NULL) {\n\n  fun &lt;- convert_to_function(formula)\n\n  fun &lt;- eval(rlang::parse_expr(fun))\n  function_args &lt;- rlang::fn_fmls_names(fun)\n  function_args &lt;- function_args[function_args!=\"value\"]\n  return(list(fun = fun,\n              args = function_args,\n              value = value))\n}\n\nFor funtional programming, we use list to store the information of a new column, including the formula function, the needed arguments(columns), and the derived value.\n\n\n3.derive columns from formula\n\nderive_columns &lt;- function(original_df, derive_infos) {\n  df_names &lt;- names(original_df)\n  derived_names &lt;- names(derive_infos)\n\n  all_args &lt;- unlist(purrr::map(derive_infos, ~.x$args))\n\n  if (!all(all_args %in% c(df_names, derived_names))) {\n    stop(\"derived columns require columns should exist in original data.\")\n  }\n\n  columns &lt;- recursive_column_calculation(original_df, derive_infos)\n\n  return(columns)\n}\n\n# derive new columns\nrecursive_column_calculation &lt;- function(original_df, derive_infos) {\n\n    cols_name &lt;- names(derive_infos)\n    for (column_name in cols_name) {\n        fun &lt;- derive_infos[[column_name]]\n        if (all(fun$args %in% names(original_df))) {\n            original_df[[column_name]] &lt;- do.call(fun$fun,\n                                                    append(lapply(fun$args, \\(x) original_df[[x]]), list(value = fun$value))) %&gt;%\n                as.vector()\n            derive_infos[[column_name]] &lt;- NULL\n            if (length(derive_infos) == 0) {\n                break()\n            } else {\n                original_df &lt;- recursive_column_calculation(original_df, derive_infos)\n            }\n        }\n    }\n    return(original_df)\n}\n\neverthing is ready for deriving the new columns. we will find the argument derive_infos of derive_columns is a list that from the result of derived_column_functions. that means however many columns there need to be derived, we can use the purrr::map to do a loop efficiently.\nBased on the deriven_rul and original data, we can easily add new columns as below:\n\nderived_functions &lt;- purrr::map(\n  derived_rule,\n  ~derived_column_functions(.x$formula, value = .x$value)\n)\ndf1 &lt;- derive_columns(df, derived_functions)\n\n\n\n\n\n\nSUBJID\nGROUP\nAVAL\nlevel_1\nlevel_2\nlevel_1_new\nlevel_2_new\n\n\n\n\nS1\nB\n18\nNA\nNA\nNA\nNA\n\n\nS2\nB\n19\nNA\nNA\nNA\nNA\n\n\nS3\nA\n11\nlevel 1\nNA\nlevel 1\nNA\n\n\nS4\nB\n1\nNA\nlevel 2\nNA\nlevel 2\n\n\nS5\nA\n12\nlevel 1\nNA\nlevel 1\nNA\n\n\nS6\nA\n17\nlevel 1\nNA\nlevel 1\nNA\n\n\nS7\nB\n9\nNA\nNA\nNA\nNA\n\n\nS8\nC\n7\nNA\nNA\nNA\nNA\n\n\nS9\nA\n4\nlevel 1\nNA\nlevel 1\nNA\n\n\nS10\nB\n5\nNA\nNA\nNA\nNA"
  },
  {
    "objectID": "posts/manipulate/formula_derive.html#method-2",
    "href": "posts/manipulate/formula_derive.html#method-2",
    "title": "Derive new columns based on given formula",
    "section": "Method 2",
    "text": "Method 2\nanother way of handling the formula is evaluate the fomula string directly instead of converting it to function firstly.\n\ncond &lt;- c(\n    quote(AVAL&gt;3 & GROUP == \"A\")\n)\ndf2 &lt;- df %&gt;% mutate(level_1 = ifelse(eval(do.call(\"substitute\", cond)), 'level 1', NA_character_))\n\n\n\n\n\n\nSUBJID\nGROUP\nAVAL\nlevel_1\nlevel_2\n\n\n\n\nS1\nB\n18\nNA\nNA\n\n\nS2\nB\n19\nNA\nNA\n\n\nS3\nA\n11\nlevel 1\nNA\n\n\nS4\nB\n1\nNA\nlevel 2\n\n\nS5\nA\n12\nlevel 1\nNA\n\n\nS6\nA\n17\nlevel 1\nNA\n\n\nS7\nB\n9\nNA\nNA\n\n\nS8\nC\n7\nNA\nNA\n\n\nS9\nA\n4\nlevel 1\nNA\n\n\nS10\nB\n5\nNA\nNA\n\n\n\n\n\n\n\nbut I think it is neither robust enough on the perspective of data processing, nor the functional programming in R. it is also easily lead to the risk of data leak in the process, some records may can’t be identified by this way."
  },
  {
    "objectID": "posts/manipulate/draft_tlf_generator.html",
    "href": "posts/manipulate/draft_tlf_generator.html",
    "title": "Draft TLF generator",
    "section": "",
    "text": "Please find the code of this section in  https://posit.cloud/content/5870060\nlibrary(checkmate)\nlibrary(R6)\nlibrary(assertive)\nlibrary(dplyr)\nlibrary(rlang)\nlibrary(Hmisc)\nlibrary(data.table)\nlibrary(rtables)\nbox::use(R/utils)\nsource(\"R/rtables_fct.R\")\nsource(\"R/tlf_pgm.R\")"
  },
  {
    "objectID": "posts/manipulate/draft_tlf_generator.html#adsmodel",
    "href": "posts/manipulate/draft_tlf_generator.html#adsmodel",
    "title": "Draft TLF generator",
    "section": "AdsModel",
    "text": "AdsModel\nCreate a AdsModel to manage the datasets level process\n\n#' @title AdsModel Class\n#'\n#'\n#' @description\n#' This is the  base class for ADaM dataset, to manage the CDISC attributes on dataset level\n#'\n#' AdsModel are build around the three following key parts:\n#'\n#' * Methods\n#'\n#'\n\n\nAdsModel &lt;- R6::R6Class(\n    \"AdsModel\",\n    public = list(\n        initialize = function(...){\n            df_lst &lt;-  tibble::lst(...)\n            if(is.character(check_list(df_lst, min.len = 1))){\n                # message(\"No datasets passed\")\n            }else{\n                df_lst &lt;- purrr::map2(df_lst, names(df_lst), ~utils$add_model_name(.x, .y))\n                private$.dataset &lt;- private$.dataset |&gt; append(df_lst)\n            }\n\n        },\n        #' retrieve datasets from AdsModel by names\n        get_dataset = function(domain){\n            if(missing(domain)){\n                return(private$.dataset)\n            }else{\n                checkmate::check_character(domain,\n                                           min.chars = 1L,\n                                           any.missing = FALSE)\n                if(length(domain) == 1){\n                    return(purrr::keep_at(private$.dataset, domain)[[1]])\n                }else{\n                    return(purrr::keep_at(private$.dataset, domain))\n                }\n\n            }\n        },\n        add_dataset = function(...){\n            df_lst &lt;-  tibble::lst(...)\n            if(is.character(check_list(df_lst, min.len = 1))){\n                message(\"No datasets passed\")\n            }else{\n                df_lst &lt;- purrr::map2(df_lst, names(df_lst), ~utils$add_model_name(.x, .y))\n                private$.dataset &lt;- private$.dataset |&gt; append(df_lst)\n            }\n\n        },\n        #' load dataset from disk\n        #'\n        #' @param path the database directory\n        #' @param domain the dataset names\n        load_dataset = function(path = NULL, domains){\n\n            df_lst &lt;- lapply(domains, \\(domain) haven::read_xpt(file.path(path, paste0(domain, \".xpt\"))))\n            names(df_lst) &lt;- domains\n            private$.dataset &lt;- private$.dataset |&gt; append(df_lst)\n        },\n        remove_dataset = function(...){\n            # to be developed\n        }\n    ),\n    active = list(\n        dataset = function(){\n            return(private$.dataset)\n        }\n    ),\n    private = list(\n        .dataset = list()\n    )\n)\n\n\nUsed functions\n\n\n add_model_name  (click)\n\n\n#' add a Model name attribute to data.frame\nadd_model_name &lt;- function(df, name){\n    attr(df, 'Model') &lt;-toupper(name)\n    return(df)\n}\n\n\n\n\nSteps\n\n# test &lt;- AdsModel$new(adsl)\nadsl &lt;- haven::read_xpt('../../data/adam/adsl.xpt')\ntest &lt;- AdsModel$new()\n\ntest$initialize(adsl)\n\n# retrieve data by 'dataset'\nnames(test$dataset)\n\n[1] \"adsl\"\n\n\n\ntmp &lt;- test$get_dataset('adsl')\n#the updated attribute 'Model'\nattributes(tmp)$Model\n\n[1] \"ADSL\"\n\n\n\nadtte &lt;- haven::read_xpt('../../data/adam/adtte.xpt')\n\n# add dataset to instance\ntest$add_dataset(adtte)\nnames(test$dataset)\n\n[1] \"adsl\"  \"adtte\"\n\ntmp2 &lt;- test$get_dataset('adtte')\nattributes(tmp2)$Model\n\n[1] \"ADTTE\""
  },
  {
    "objectID": "posts/manipulate/draft_tlf_generator.html#variableproc",
    "href": "posts/manipulate/draft_tlf_generator.html#variableproc",
    "title": "Draft TLF generator",
    "section": "VariableProc",
    "text": "VariableProc\nCreate a VariableProc to manage the variable level process\n\nVariableProc &lt;- R6::R6Class(\n  \"VariableProc\",\n  inherit = AdsModel,\n  public = list(\n    # save the dictionary\n    dictionary = list(),\n    initialize = function(dictionary_path = NA){\n\n      #check dictionary_path is string\n      if(!is.na(dictionary_path)){\n        utils$check_dictionary_path(dictionary_path, \"dictionary_path\")\n        dictionary &lt;-  jsonlite::fromJSON(dictionary_path)\n        self$dictionary &lt;- dictionary\n      }\n\n    },\n    get_decode = function(){\n      if(is.character(check_list(self$dictionary, min.len = 1))){\n        message(\"No dictionary avaiable, the variables will not be decoded\")\n      }else{\n        private$.dataset &lt;- purrr::map(private$.dataset, ~utils$set_attr(df = ., dictionary = self$dictionary))\n      }\n\n    },\n    update_decode = function(dataset = NA, dictionary = \"\"){\n      #check if the dataset exist first\n      #check the format of dictionary\n\n      # to be developed\n    },\n    update_detail = function(){\n      # element track which dataset and variable be decoded, is it necessary integrated to S3 'summary'?\n\n      # to be developed\n    }\n  ),\n\n  #set dataset private, except variable attribute, user can't modify dataset in this module\n  private = list(\n    .dataset = list()\n  )\n)\n\n\nthe VariableProc inherit from AdsModel\nmethod get_decode set attributes format to variables\n\n\nUsed functions\n\n\n set_attr  (click)\n\n\n#' add \"format\" attributes to the variables of passed datasets\n#'\n#' @param df\n#' @param dictionary\n#' @param .vars the variables used to be assisgned the attributes\nset_attr &lt;- function(df, dictionary, .vars){\n\n    sub_dict &lt;- purrr::keep_at(dictionary, colnames(df))\n\n    for (var in names(sub_dict)) {\n        var_N &lt;- ifelse(paste0(var, 'N') %in% colnames(df), paste0(var, 'N'), 'NA')\n        attr(df[[var]], \"format\") &lt;- list(\"Value\" =  names(sub_dict[[var]]),\n                                          \"Decode\" = purrr::map_vec(sub_dict[[var]], 1),\n                                          \"Numeric variable\" = var_N,\n                                          \"Ordinal\" = names(sub_dict[[var_N]]))\n    }\n\n    return(df)\n}\n\n\n\n\nSteps\n\ntest2 &lt;- VariableProc$new()\n\ntest2$initialize(dictionary_path = \"dictionary.json\")\n\ntest2$add_dataset(adsl)\nadsl_tmp &lt;- test2$get_dataset('adsl')\n\n# inherit the AdsModel method\nattributes(adsl_tmp)$Model\n\n[1] \"ADSL\"\n\n# before setting the format\nattributes(adsl_tmp$SEX)$format\n\nNULL\n\n\n\n# set the format by get_decode()\ntest2$get_decode()\n\nadsl_tmp2 &lt;- test2$get_dataset('adsl')\n\n# the format is set from dictionary.json\nattributes(adsl_tmp2$SEX)$format\n\n$Value\n[1] \"M\" \"F\"\n\n$Decode\n       M        F \n  \"Male\" \"Female\" \n\n$`Numeric variable`\n[1] \"NA\"\n\n$Ordinal\nNULL\n\nattributes(adsl_tmp2$AGEGR1)$format\n\n$Value\n[1] \"&lt;65\"   \"65-80\" \"&gt;80\"  \n\n$Decode\n    &lt;65   65-80     &gt;80 \n  \"&lt;65\" \"65-80\"   \"&gt;80\" \n\n$`Numeric variable`\n[1] \"AGEGR1N\"\n\n$Ordinal\n[1] \"1\" \"2\" \"3\"\n\n\n\n\nTLFProc\nCreate a TLFProc to generate the outputs\n\nTLFProc &lt;- R6::R6Class(\n  \"TLFProc\",\n  public = list(\n\n    #' Stores the object of the outputs\n    tlfs = NULL,\n\n    #' Store the metadata\n    tlfmetadata = NULL,\n\n    #' create a new environment for TLFProc\n    initialize = function(config = NULL) {\n      self$tlfs = new.env(parent = emptyenv())\n      if(!is.null(config)){\n        self$add_tlfmetadata(config)\n      }\n    },\n    #' return avaialable outputs name\n    has_outputs = function(pattern = NULL) {\n      outputs = ls(self$tlfs, all.names = TRUE)\n      if (!is.null(pattern)) {\n        assert_string(pattern)\n        outputs = outputs[grepl(pattern, outputs)]\n      }\n      outputs\n    },\n\n    #' get output by name\n    get = function(output, ...) {\n      assert_string(output, min.chars = 1L)\n      # return output\n      obj = get0(output, envir = self$tlfs, inherits = FALSE, ifnotfound = NULL)\n      return(obj)\n    },\n\n    #' get a list of outputs\n    mget = function(outputs, ...) {\n      assert_character(outputs, min.chars = 1L, any.missing = FALSE)\n      # return\n      set_names(lapply(outputs, self$get, ...), outputs)\n    },\n    # read yaml configuration\n    add_tlfmetadata = function(config) {\n      assert_string(config, min.chars = 1L)\n      assert(check_file_exists(config))\n\n      metadata &lt;- yaml::read_yaml(config)\n      self$tlfmetadata &lt;- purrr::map(metadata, utils$parse_mtdata)\n      #\n    },\n\n    #' Generate the TLFs\n    #' @param VariableProc the instance VariableProc with decoded dataset\n    #' @param tlmetadata  the passed metadata\n    generator = function(VariableProc, tlfmetadata = self$tlfmetadata){\n\n      #check VariableProc\n      #check tlfmetadata\n\n      domains &lt;- purrr::map(tlfmetadata, ~purrr::pluck(.x, \"domains\"))  |&gt;\n        purrr::list_simplify()  |&gt;\n        unique()\n\n      # dynamically construct a standard tlf template function with the metadata?\n      # args_list &lt;- list()\n      purrr::walk2(tlfmetadata,\n                   names(tlfmetadata),\n                   ~assign(x = .y,\n                           value = do.call(\"demo_t_generator\",\n                                           list(dataset = VariableProc$get_dataset(domains),\n                                                columns = .x$variables,\n                                                columns_label = .x$variables,\n                                                string_variable  = .x$string_variable,\n                                                header_variable = .x$header_variable,\n                                                header_order = .x$header_order,\n                                                population_variable = .x$population_variable)),\n                           envir = self$tlfs),\n                   .progress = TRUE)\n\n      invisible(self)\n    },\n    remove = function(keys) {\n      i = wf(!self$has(keys))\n      rm(list = keys, envir = self$items)\n      invisible(self)\n    }\n  )\n)\n\n\nUsed functions\n\n\n parse_mtdata  (click)\n\n\nparse_mtdata &lt;- function(metadata){\n\n    # check the structure of metadata\n\n    #------------------------------#\n    #------------------------------#\n\n    #check the results\n\n    return(list(variables = names(metadata$columns),\n                string_variable = names(purrr::keep(metadata$columns, ~.x$type == \"string\")),\n                domains = purrr::map_vec(metadata$columns, ~purrr::pluck(.x, 'domain'))  |&gt;  unique(),\n                header_variable = purrr::pluck(metadata, \"header\")$variable,\n                header_order = purrr::pluck(metadata, \"header\")$order,\n                population_variable = purrr::pluck(metadata, \"population\")$variable)\n    )\n}\n\n\n\n\n demo_t_generator  (click)\n\n\ndemo_t_generator &lt;- function(dataset, columns, columns_label, string_variable, header_variable, header_order, population_variable){\n\n    names(header_variable) &lt;- NULL\n\n    adsl &lt;- dataset %&gt;%\n        select(USUBJID, all_of(population_variable), all_of(header_variable), all_of(header_order), all_of(columns)) %&gt;%\n        filter(!!as.name(population_variable) == \"Y\")\n    # %&gt;%\n    #   mutate(across(string_variable, ~ifelse(.==\"\", \"Missing_value_impute\", as.character(.))))\n\n    adsl_fact &lt;- adsl %&gt;%\n        mutate(across(all_of(string_variable),\n                      ~factor(attributes(cur_data()[[cur_column()]])$format$Decode[.x],\n                              levels = attributes(cur_data()[[cur_column()]])$format$Decode)))\n\n    if(isTRUE(is.na(header_order))){\n        adsl_fact &lt;- adsl_fact %&gt;%\n            mutate(across(all_of(header_variable),\n                          ~factor(attributes(cur_data()[[cur_column()]])$format$Decode[.x],\n                                  levels = attributes(cur_data()[[cur_column()]])$format$Decode)))\n    }else{\n        adsl_fact &lt;- df_order_header(adsl_fact, c(header_variable, header_order))\n    }\n\n    col_counts &lt;- table(adsl[[header_variable]]) %&gt;% as.vector()\n    col_counts &lt;- c(col_counts, sum(col_counts))\n\n    calculated_t &lt;- basic_table() %&gt;%\n        split_cols_by(header_variable) %&gt;%\n        add_overall_col(\"All\") %&gt;%\n        summarize_vars(\n            vars = columns,\n            var_labels = columns_label,\n            dispfmt = c(\"npct\"),\n            decimal = 1,\n            denom = c(\"col\"),\n            unique_row = TRUE\n        ) %&gt;%\n        rtables::build_table(adsl_fact, col_counts = col_counts)\n\n    return(calculated_t)\n}\n\n\n\n\nSteps\n\ninitialize a new instance of TLFProc, add tlfmetadata mock.yaml\n\n\ntlfp &lt;- TLFProc$new()\n\ntlfp$add_tlfmetadata(\"mock.yaml\")\n\n\n\n mock.yaml  (click)\n\n\ndemographic_example1:\n  columns:\n    AGEGR1:\n      domain: adsl\n      type: string\n      label: Age Goup (n[%])\n    AGE:\n      domain: adsl\n      type: numberic\n      label: Age\n      stats: N Mean Median Q1 Q3 Min Max\n    SEX:\n      domain: adsl\n      type: string\n      label: Sex (n[%])\n  header:\n    variable:\n      TRT01A\n    order:\n      TRT01AN\n  population:\n    variable:\n      SAFFL\ndemographic_example2:\n  columns:\n    RACE:\n      domain: adsl\n      type: string\n      label: Race (n[%])\n    AGEGR1N:\n      domain: adsl\n      type: string\n      label: Age Goup (n[%])\n    BMIBL:\n      domain: adsl\n      type: numberic\n      label: Baseline BMI (kg/m^2)\n      stats: N Mean Median Q1 Q3 Min Max\n    BMIBLGR1:\n      domain: adsl\n      type: string\n      label: Baseline BMI Agroup\n  header:\n    variable:\n      SEX\n    order:\n      NULL\n  population:\n    variable:\n      DISCONFL\n\n\n\n\n\ntlfp$tlfmetadata\n\n\n\n\n$demographic_example1\n$demographic_example1$variables\n[1] \"AGEGR1\" \"AGE\"    \"SEX\"   \n\n$demographic_example1$string_variable\n[1] \"AGEGR1\" \"SEX\"   \n\n$demographic_example1$domains\n[1] \"adsl\"\n\n$demographic_example1$header_variable\n[1] \"TRT01A\"\n\n$demographic_example1$header_order\n[1] \"TRT01AN\"\n\n$demographic_example1$population_variable\n[1] \"SAFFL\"\n\n\n$demographic_example2\n$demographic_example2$variables\n[1] \"RACE\"     \"AGEGR1N\"  \"BMIBL\"    \"BMIBLGR1\"\n\n$demographic_example2$string_variable\n[1] \"RACE\"     \"AGEGR1N\"  \"BMIBLGR1\"\n\n$demographic_example2$domains\n[1] \"adsl\"\n\n$demographic_example2$header_variable\n[1] \"SEX\"\n\n$demographic_example2$header_order\nNULL\n\n$demographic_example2$population_variable\n[1] \"DISCONFL\"\n\n\n\n\nGet all the needed datasets from metadata\n\n\ndomains &lt;- purrr::map(tlfp$tlfmetadata, ~purrr::pluck(.x, \"domains\"))  |&gt;\n        purrr::list_simplify()  |&gt;\n        unique()\n\n\ninitialize a new instance of VaribaleProc with the dictionary of variables dictionary.json,\nload needed datasets\nadd attribute format to variables by get_decode()\n\n\nvarpoc &lt;- VariableProc$new()\n\nvarpoc$initialize(dictionary_path = \"dictionary.json\")\n\nvarpoc$load_dataset(path = \"../../data/adam\", domains = domains)\nvarpoc$get_decode()\n\n\n\n dictionary.json  (click)\n\n\n{\n  \"AGEGR1\": {\n    \"&lt;65\": [\"&lt;65\"],\n    \"65-80\": [\"65-80\"],\n    \"&gt;80\": [\"&gt;80\"]\n  },\n    \"AGEGR1N\": {\n    \"1\": [\"&lt;65\"],\n    \"2\": [\"65-80\"],\n    \"3\": [\"&gt;80\"]\n  },\n  \"SEX\": {\n    \"M\": [\"Male\"],\n    \"F\": [\"Female\"]\n  },\n  \"RACE\": {\n    \"WHITE\": [\"White\"],\n    \"BLACK OR AFRICAN AMERICAN\": [\"Black Or African American\"],\n    \"AMERICAN INDIAN OR ALASKA NATIVE\": [\"American Indian Or Alaska Native\"]\n  },\n  \"BMIBLGR1\": {\n    \"&lt;25\": [\"&lt;25\"],\n    \"25-&lt;30\": [\"25-&lt;30\"],\n    \"&gt;=30\": [\"&gt;=30\"]\n  }\n}\n\n\n\nGenerate the outputs\n\n\ntlfp$generator(VariableProc = varpoc)\n\n\nCheck what the outputs we have in tlfp\n\n\ntlfp$has_outputs()\n\n[1] \"demographic_example1\" \"demographic_example2\"\n\ntlfp$has_outputs(\"1\")\n\n[1] \"demographic_example1\"\n\n\n\nthe tlf metadata of the table demographic_example1\n\n\ntlfp$tlfmetadata$demographic_example1\n\n$variables\n[1] \"AGEGR1\" \"AGE\"    \"SEX\"   \n\n$string_variable\n[1] \"AGEGR1\" \"SEX\"   \n\n$domains\n[1] \"adsl\"\n\n$header_variable\n[1] \"TRT01A\"\n\n$header_order\n[1] \"TRT01AN\"\n\n$population_variable\n[1] \"SAFFL\"\n\n\n\nRetrieve the outputs\n\n\ntlfp$get(\"demographic_example1\")\n\n\n\n\nPlaceboXanomeline Low DoseXanomeline High DoseAll(N=86)(N=84)(N=84)(N=254)AGEGR1  &lt;6514 (16.3)8 (9.5)11 (13.1)33 (13.0)  65-8042 (48.8)47 (56.0)55 (65.5)144 (56.7)  &gt;8030 (34.9)29 (34.5)18 (21.4)77 (30.3)   AGE  Number868484254  Mean (SD)75.2 (8.6)75.7 (8.3)74.4 (7.9)75.1 (8.2)  Median76.077.576.077.0  Q1 ; Q369 ; 8271 ; 8270.5 ; 8070 ; 81  Min ; Max52 ; 8951 ; 8856 ; 8851 ; 89   SEX  Male33 (38.4)34 (40.5)44 (52.4)111 (43.7)  Female53 (61.6)50 (59.5)40 (47.6)143 (56.3)   \n\n\n\ntlfp$tlfmetadata$demographic_example1\n\n$variables\n[1] \"AGEGR1\" \"AGE\"    \"SEX\"   \n\n$string_variable\n[1] \"AGEGR1\" \"SEX\"   \n\n$domains\n[1] \"adsl\"\n\n$header_variable\n[1] \"TRT01A\"\n\n$header_order\n[1] \"TRT01AN\"\n\n$population_variable\n[1] \"SAFFL\"\n\n\n\ntlfp$get(\"demographic_example2\")\n\n\n\n\nFMAll(N=79)(N=65)(N=144)RACE  White71 (89.9)61 (93.8)132 (91.7)  Black Or African American8 (10.1)3 (4.6)11 (7.6)  American Indian Or Alaska Native01 (1.5)1 (0.7)   AGEGR1N  &lt;659 (11.4)8 (12.3)17 (11.8)  65-8040 (50.6)36 (55.4)76 (52.8)  &gt;8030 (38.0)21 (32.3)51 (35.4)   BMIBL  Number7865143  Mean (SD)23.9 (4.1)26.1 (3.3)24.9 (3.9)  Median23.125.624.3  Q1 ; Q321 ; 25.723.2 ; 28.422.1 ; 27.6  Min ; Max15 ; 3921 ; 3415 ; 39   BMIBLGR1  &lt;2557 (72.2)27 (41.5)84 (58.3)  25-&lt;3014 (17.7)29 (44.6)43 (29.9)  &gt;=308 (10.1)9 (13.8)17 (11.8)   \n\n\n \n\nthe size of tlfp\n\n\nprint(object.size(tlfp))\n\n344 bytes\n\n\n\nTransform the class of rtables\n\n\ntable_to_dataframe &lt;- function(tbl) {\n\n  # check the tabl classs\n\n  matrix_tbl &lt;- tbl %&gt;% rtables::matrix_form()\n\n  tbl_strings &lt;- as.data.frame(matrix_tbl$strings)\n\n\n  ## get the hader index from tbl attributes\n  nrow_header &lt;- attributes(matrix_tbl)$nrow_header\n\n  ## get the body of tbl\n  tbl_body &lt;- tbl_strings[-c(1:nrow_header), ]\n\n  ## get the header of tbl\n  tbl_header &lt;- tbl_strings[c(1:nrow_header), ]\n\n  attr(tbl_body, \"tbl_header\") &lt;- tbl_header\n\n\n\n  return(tbl_body)\n}\n\n\ntbl &lt;-  tlfp$get(\"demographic_example2\") |&gt; table_to_dataframe()\n\n\n\n\n\n\n\nV1\nV2\nV3\nV4\n\n\n\n\n3\nRACE\n\n\n\n\n\n4\nWhite\n71 (89.9)\n61 (93.8)\n132 (91.7)\n\n\n5\nBlack Or African American\n8 (10.1)\n3 (4.6)\n11 (7.6)\n\n\n6\nAmerican Indian Or Alaska Native\n0\n1 (1.5)\n1 (0.7)\n\n\n7\n\n\n\n\n\n\n8\nAGEGR1N\n\n\n\n\n\n9\n&lt;65\n9 (11.4)\n8 (12.3)\n17 (11.8)\n\n\n10\n65-80\n40 (50.6)\n36 (55.4)\n76 (52.8)\n\n\n11\n&gt;80\n30 (38.0)\n21 (32.3)\n51 (35.4)\n\n\n12\n\n\n\n\n\n\n13\nBMIBL\n\n\n\n\n\n14\nNumber\n78\n65\n143\n\n\n15\nMean (SD)\n23.9 (4.1)\n26.1 (3.3)\n24.9 (3.9)\n\n\n16\nMedian\n23.1\n25.6\n24.3\n\n\n17\nQ1 ; Q3\n21 ; 25.7\n23.2 ; 28.4\n22.1 ; 27.6\n\n\n18\nMin ; Max\n15 ; 39\n21 ; 34\n15 ; 39\n\n\n19\n\n\n\n\n\n\n20\nBMIBLGR1\n\n\n\n\n\n21\n&lt;25\n57 (72.2)\n27 (41.5)\n84 (58.3)\n\n\n22\n25-&lt;30\n14 (17.7)\n29 (44.6)\n43 (29.9)\n\n\n23\n&gt;=30\n8 (10.1)\n9 (13.8)\n17 (11.8)\n\n\n24\n\n\n\n\n\n\n\n\n\n\n\n\nattributes(tbl)\n\n$names\n[1] \"V1\" \"V2\" \"V3\" \"V4\"\n\n$row.names\n [1]  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n\n$class\n[1] \"data.frame\"\n\n$tbl_header\n  V1     V2     V3      V4\n1         F      M     All\n2    (N=79) (N=65) (N=144)"
  },
  {
    "objectID": "posts/manipulate/dplyr_cross.html",
    "href": "posts/manipulate/dplyr_cross.html",
    "title": "Derive multiple columns based on across",
    "section": "",
    "text": "library(dplyr)"
  },
  {
    "objectID": "posts/manipulate/dplyr_cross.html#reale-case",
    "href": "posts/manipulate/dplyr_cross.html#reale-case",
    "title": "Derive multiple columns based on across",
    "section": "Reale Case",
    "text": "Reale Case\nSuppose we this data with columns num_var1_1, num_var1_99 and denom1_1, denom1_99\n\ntest_data &lt;- data.frame(num_var1_1 = c(1, 4),\n                        num_var1_99 = c(2, 6),\n                        denom1_1 = c(2, 5),\n                        denom1_99 = c(3, 1))\n\nwhat we want to do is to add two new columns: the new column equal to the sum of num_var_x and denom1_y. Just fit the data into the function sum_c\n\nsum_c &lt;- function(x, y){\n  ifelse(y &gt; 2, x+y+10, x+y)\n}\n\ntest_data1 &lt;- test_data %&gt;%\n             mutate(var1_1 = sum_c(num_var1_1, denom1_1),\n                    var1_99 = sum_c(num_var1_99, denom1_99))\n\n\n\n\n\n\nnum_var1_1\nnum_var1_99\ndenom1_1\ndenom1_99\nvar1_1\nvar1_99\n\n\n\n\n1\n2\n2\n3\n3\n15\n\n\n4\n6\n5\n1\n19\n7\n\n\n\n\n\n\n\nthe code seems repetitive and not readable."
  },
  {
    "objectID": "posts/manipulate/dplyr_cross.html#dplyracross",
    "href": "posts/manipulate/dplyr_cross.html#dplyracross",
    "title": "Derive multiple columns based on across",
    "section": "dplyr::across()",
    "text": "dplyr::across()\nwe can use the across() to easily apply the functions to the selected columns.\nDescription\nacross() makes it easy to apply the same transformation to multiple columns, allowing you to use select() semantics inside in “data-masking” functions like summarise() and mutate(). See vignette(\"colwise\") for more details.\nUsage\n\nacross(.cols = everything(), .fns = NULL, ..., .names = NULL)\n\nArguments\n\n\n\n\n\n\n\n.cols\n&lt;tidy-select&gt; Columns to transform. You can’t select grouping columns because they are already automatically handled by the verb (i.e. summarise() or mutate()).\n\n\n.fns\nFunctions to apply to each of the selected columns. Possible values are:\n\n\n\n\nA function, e.g. mean.\nA purrr-style lambda, e.g. ~ mean(.x, na.rm = TRUE)\nA list of functions/lambdas, e.g. list(mean = mean, n_miss = ~ sum(is.na(.x))\nNULL: the default value, returns the selected columns in a data frame without applying a transformation. This is useful for when you want to use a function that takes a data frame.\n\nWithin these functions you can use cur_column() and cur_group() to access the current column and grouping keys respectively.\n.names| A glue specification that describes how to name the output columns. This can use {.col} to stand for the selected column name, and {.fn} to stand for the name of the function being applied. The default NULL is equivalent to {.col} for the single function case and {.col}_{.fn} for the case where a list is used for .fns.\n\nMethod 1\nTo use the across in this case:\n\ntest_data %&gt;%\n  mutate(across(.cols = starts_with('num_var1'),\n                .fns = ~sum_c(., get(gsub('num_var1', \"denom1\", cur_column()))),\n                .names = \"{gsub('num_var1', 'var1', .col)}\"))\n\n\n\n\n\n\nnum_var1_1\nnum_var1_99\ndenom1_1\ndenom1_99\nvar1_1\nvar1_99\n\n\n\n\n1\n2\n2\n3\n3\n15\n\n\n4\n6\n5\n1\n19\n7\n\n\n\n\n\n\n\nSteps:\n\nselect referenced columns by starts_with('num_var1')\napply the function sum_c. here, the first argument x is from the .cols, the second argument y is retrived by using the function cur_column().\ngive the names to new columns\n\n\n\nMethod 2\nthis code will be used for a function that can do the vectorized calculation. it’s faster that the method 1.\n\ntest_data %&gt;%\n  mutate(Vectorize(sum_c)(across(starts_with('num_var1'),\n                                 .names = \"{gsub('num_var1', 'var1', .col)}\"),\n                          across(starts_with('denom1')))) %&gt;%\n  do.call(data.frame, .) %&gt;%\n  rename_at(dplyr::vars(starts_with(\"Vectorize\")), ~ gsub(\"Vectorize.sum_c.......\", \"\", .))\n\n\n\n\n\n\nnum_var1_1\nnum_var1_99\ndenom1_1\ndenom1_99\nvar1_1\nvar1_99\n\n\n\n\n1\n2\n2\n3\n3\n15\n\n\n4\n6\n5\n1\n19\n7\n\n\n\n\n\n\n\nSteps:\n\nin the mutate, the function firstly is vectorized since we need a vector result returned.\nthe function sum_c take the first across() as argument x, the name of new columns is set in here. the second across() select the needed columns as argument y.\nboth passed value x, y actually are two dataframe. e.g. the first one is test_data %&gt;% select(starts_with('num_var1')), the second one is test_data %&gt;% select(starts_with('denom1')). to accept the dataframe value, the sum_c need to be a vectorized function.\nthe mutate return a matrix as the new column, which can be transformed by data.frame(as.data.frame not work)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "One Day",
    "section": "",
    "text": "Nice to meet you"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "One Day",
    "section": "",
    "text": "Series\n\nrtables-series\nThis series contains a great deal of tips, tricks and packages that you can use to level up your rtables game.\n\n\nmanipulate-series\nThis series contains a great deal of tips, tricks of dplyr\n\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDraft TLF generator\n\n\n\n\n\n\n\nR\n\n\nR6class\n\n\nTLF\n\n\n\n\nDraft the TLF generator tool\n\n\n\n\n\n\nApr 25, 2023\n\n\n19 min\n\n\n\n\n\n\n\n\nDerive new columns based on given formula\n\n\n\n\n\n\n\nR\n\n\ndplyr\n\n\nglue\n\n\nDerive\n\n\n\n\nEfficiently Derive new columns based on formula\n\n\n\n\n\n\nApr 16, 2023\n\n\n5 min\n\n\n\n\n\n\n\n\nMutiple level calculation 4\n\n\n\n\n\n\n\nR\n\n\nrtables\n\n\n\n\nmultiple level counts more than 2 levels\n\n\n\n\n\n\nApr 11, 2023\n\n\n8 min\n\n\n\n\n\n\n\n\nMutiple level calculation 3\n\n\n\n\n\n\n\nR\n\n\nrtables\n\n\n\n\nsummary counts by summarize_row_groups\n\n\n\n\n\n\nApr 10, 2023\n\n\n14 min\n\n\n\n\n\n\n\n\nMutiple level calculation 2\n\n\n\n\n\n\n\nR\n\n\nrtables\n\n\n\n\nWrap the analysis function\n\n\n\n\n\n\nApr 9, 2023\n\n\n14 min\n\n\n\n\n\n\n\n\nDerive multiple columns based on across\n\n\n\n\n\n\n\nR\n\n\ndplyr\n\n\nacross\n\n\n\n\nWhen we want to add new columns and have to iterate…\n\n\n\n\n\n\nApr 8, 2023\n\n\n5 min\n\n\n\n\n\n\n\n\nMutiple level calculation 1\n\n\n\n\n\n\n\nR\n\n\nrtables\n\n\n\n\nExplore how to handle the mutiple calculation by rtables\n\n\n\n\n\n\nApr 7, 2023\n\n\n15 min\n\n\n\n\n\n\n\n\nCustomize the format of rcell\n\n\n\n\n\n\n\nR\n\n\nrtables\n\n\n\n\nConstruct a cell value and associate formatting\n\n\n\n\n\n\nApr 6, 2023\n\n\n4 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "rtables-series.html",
    "href": "rtables-series.html",
    "title": "Series: rtables",
    "section": "",
    "text": "Mutiple level calculation 4\n\n\n\n\n\nmultiple level counts more than 2 levels\n\n\n\n\n\n\nApr 11, 2023\n\n\n8 min\n\n\n\n\n\n\n\n\nMutiple level calculation 3\n\n\n\n\n\nsummary counts by summarize_row_groups\n\n\n\n\n\n\nApr 10, 2023\n\n\n14 min\n\n\n\n\n\n\n\n\nMutiple level calculation 2\n\n\n\n\n\nWrap the analysis function\n\n\n\n\n\n\nApr 9, 2023\n\n\n14 min\n\n\n\n\n\n\n\n\nMutiple level calculation 1\n\n\n\n\n\nExplore how to handle the mutiple calculation by rtables\n\n\n\n\n\n\nApr 7, 2023\n\n\n15 min\n\n\n\n\n\n\n\n\nCustomize the format of rcell\n\n\n\n\n\nConstruct a cell value and associate formatting\n\n\n\n\n\n\nApr 6, 2023\n\n\n4 min\n\n\n\n\n\n\nNo matching items"
  }
]
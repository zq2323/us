---
title: 'Draft TLF generator'
date: '2023-04-25'
author: Qing Zou
categories: ['R', 'R6class', 'TLF']
description: 'Draft the TLF generator tool'
execute:
  message: false
  warning: false
editor_options:
  chunk_output_type: console
---


```{r rcell0}
library(checkmate)
library(R6)
library(assertive)
library(dplyr)
library(rlang)
library(Hmisc)
library(data.table)
library(rtables)
box::use(R/utils)
source("R/rtables_fct.R")
source("R/tlf_pgm.R")
```

## AdsModel

Create a `AdsModel` to manage the datasets level process

```{r rcell15}
#| echo: true
#| eval: true
#' @title AdsModel Class
#'
#'
#' @description
#' This is the  base class for ADaM dataset, to manage the CDISC attributes on dataset level
#'
#' AdsModel are build around the three following key parts:
#'
#' * Methods
#'
#'


AdsModel <- R6::R6Class(
    "AdsModel",
    public = list(
        initialize = function(...){
            df_lst <-  tibble::lst(...)
            if(is.character(check_list(df_lst, min.len = 1))){
                # message("No datasets passed")
            }else{
                df_lst <- purrr::map2(df_lst, names(df_lst), ~utils$add_model_name(.x, .y))
                private$.dataset <- private$.dataset |> append(df_lst)
            }

        },
        #' retrieve datasets from AdsModel by names
        get_dataset = function(domain){
            if(missing(domain)){
                return(private$.dataset)
            }else{
                checkmate::check_character(domain,
                                           min.chars = 1L,
                                           any.missing = FALSE)
                if(length(domain) == 1){
                    return(purrr::keep_at(private$.dataset, domain)[[1]])
                }else{
                    return(purrr::keep_at(private$.dataset, domain))
                }

            }
        },
        add_dataset = function(...){
            df_lst <-  tibble::lst(...)
            if(is.character(check_list(df_lst, min.len = 1))){
                message("No datasets passed")
            }else{
                df_lst <- purrr::map2(df_lst, names(df_lst), ~utils$add_model_name(.x, .y))
                private$.dataset <- private$.dataset |> append(df_lst)
            }

        },
        #' load dataset from disk
        #'
        #' @param path the database directory
        #' @param domain the dataset names
        load_dataset = function(path = NULL, domains){

            df_lst <- lapply(domains, \(domain) haven::read_xpt(file.path(path, paste0(domain, ".xpt"))))
            names(df_lst) <- domains
            private$.dataset <- private$.dataset |> append(df_lst)
        },
        remove_dataset = function(...){
            # to be developed
        }
    ),
    active = list(
        dataset = function(){
            return(private$.dataset)
        }
    ),
    private = list(
        .dataset = list()
    )
)
```

#### Used functions

<details><summary  class = "block2"> <font color="blue"> add_model_name </font> __(click)__ </summary>
```{r}
#| echo: true
#| eval: false
#' add a Model name attribute to data.frame
add_model_name <- function(df, name){
    attr(df, 'Model') <-toupper(name)
    return(df)
}
```
</details>


#### Steps
```{r}
#| echo: true
#| eval: true
# test <- AdsModel$new(adsl)
adsl <- haven::read_xpt('../../data/adam/adsl.xpt')
test <- AdsModel$new()

test$initialize(adsl)

# retrieve data by 'dataset'
names(test$dataset)
```

```{r}
#| echo: true
#| eval: true


tmp <- test$get_dataset('adsl')
#the updated attribute 'Model'
attributes(tmp)$Model
```

```{r}
#| echo: true
#| eval: true

adtte <- haven::read_xpt('../../data/adam/adtte.xpt')

# add dataset to instance
test$add_dataset(adtte)
names(test$dataset)
tmp2 <- test$get_dataset('adtte')
attributes(tmp2)$Model
```

## VariableProc

Create a `VariableProc` to manage the variable level process

```{r rcell116}
#| echo: true
#| eval: true

VariableProc <- R6::R6Class(
  "VariableProc",
  inherit = AdsModel,
  public = list(
    # save the dictionary
    dictionary = list(),
    initialize = function(dictionary_path = NA){

      #check dictionary_path is string
      if(!is.na(dictionary_path)){
        utils$check_dictionary_path(dictionary_path, "dictionary_path")
        dictionary <-  jsonlite::fromJSON(dictionary_path)
        self$dictionary <- dictionary
      }

    },
    get_decode = function(){
      if(is.character(check_list(self$dictionary, min.len = 1))){
        message("No dictionary avaiable, the variables will not be decoded")
      }else{
        private$.dataset <- purrr::map(private$.dataset, ~utils$set_attr(df = ., dictionary = self$dictionary))
      }

    },
    update_decode = function(dataset = NA, dictionary = ""){
      #check if the dataset exist first
      #check the format of dictionary

      # to be developed
    },
    update_detail = function(){
      # element track which dataset and variable be decoded, is it necessary integrated to S3 'summary'?

      # to be developed
    }
  ),

  #set dataset private, except variable attribute, user can't modify dataset in this module
  private = list(
    .dataset = list()
  )
)
```

- the `VariableProc` inherit from `AdsModel`
- method `get_decode` set attributes format to variables

#### Used functions

<details><summary  class = "block2"> <font color="blue"> set_attr </font> __(click)__ </summary>
```{r}
#| echo: true
#| eval: false
#' add "format" attributes to the variables of passed datasets
#'
#' @param df
#' @param dictionary
#' @param .vars the variables used to be assisgned the attributes
set_attr <- function(df, dictionary, .vars){

    sub_dict <- purrr::keep_at(dictionary, colnames(df))

    for (var in names(sub_dict)) {
        var_N <- ifelse(paste0(var, 'N') %in% colnames(df), paste0(var, 'N'), 'NA')
        attr(df[[var]], "format") <- list("Value" =  names(sub_dict[[var]]),
                                          "Decode" = purrr::map_vec(sub_dict[[var]], 1),
                                          "Numeric variable" = var_N,
                                          "Ordinal" = names(sub_dict[[var_N]]))
    }

    return(df)
}

```
</details>

#### Steps

```{r rcell11612 }
#| echo: true
#| eval: true
test2 <- VariableProc$new()

test2$initialize(dictionary_path = "dictionary.json")

test2$add_dataset(adsl)
adsl_tmp <- test2$get_dataset('adsl')

# inherit the AdsModel method
attributes(adsl_tmp)$Model

# before setting the format
attributes(adsl_tmp$SEX)$format


```

```{r}

# set the format by get_decode()
test2$get_decode()

adsl_tmp2 <- test2$get_dataset('adsl')

# the format is set from dictionary.json
attributes(adsl_tmp2$SEX)$format

attributes(adsl_tmp2$AGEGR1)$format
```

### TLFProc


Create a `TLFProc` to generate the outputs

```{r}
TLFProc <- R6::R6Class(
  "TLFProc",
  public = list(

    #' Stores the object of the outputs
    tlfs = NULL,

    #' Store the metadata
    tlfmetadata = NULL,

    #' create a new environment for TLFProc
    initialize = function(config = NULL) {
      self$tlfs = new.env(parent = emptyenv())
      if(!is.null(config)){
        self$add_tlfmetadata(config)
      }
    },
    #' return avaialable outputs name
    has_outputs = function(pattern = NULL) {
      outputs = ls(self$tlfs, all.names = TRUE)
      if (!is.null(pattern)) {
        assert_string(pattern)
        outputs = outputs[grepl(pattern, outputs)]
      }
      outputs
    },

    #' get output by name
    get = function(output, ...) {
      assert_string(output, min.chars = 1L)
      # return output
      obj = get0(output, envir = self$tlfs, inherits = FALSE, ifnotfound = NULL)
      return(obj)
    },

    #' get a list of outputs
    mget = function(outputs, ...) {
      assert_character(outputs, min.chars = 1L, any.missing = FALSE)
      # return
      set_names(lapply(outputs, self$get, ...), outputs)
    },
    # read yaml configuration
    add_tlfmetadata = function(config) {
      assert_string(config, min.chars = 1L)
      assert(check_file_exists(config))

      metadata <- yaml::read_yaml(config)
      self$tlfmetadata <- purrr::map(metadata, utils$parse_mtdata)
      #
    },

    #' Generate the TLFs
    #' @param VariableProc the instance VariableProc with decoded dataset
    #' @param tlmetadata  the passed metadata
    generator = function(VariableProc, tlfmetadata = self$tlfmetadata){

      #check VariableProc
      #check tlfmetadata

      domains <- purrr::map(tlfmetadata, ~purrr::pluck(.x, "domains"))  |>
        purrr::list_simplify()  |>
        unique()

      # dynamically construct a standard tlf template function with the metadata?
      # args_list <- list()
      purrr::walk2(tlfmetadata,
                   names(tlfmetadata),
                   ~assign(x = .y,
                           value = do.call("demo_t_generator",
                                           list(dataset = VariableProc$get_dataset(domains),
                                                columns = .x$variables,
                                                columns_label = .x$variables,
                                                string_variable  = .x$string_variable,
                                                header_variable = .x$header_variable,
                                                header_order = .x$header_order,
                                                population_variable = .x$population_variable)),
                           envir = self$tlfs),
                   .progress = TRUE)

      invisible(self)
    },
    remove = function(keys) {
      i = wf(!self$has(keys))
      rm(list = keys, envir = self$items)
      invisible(self)
    }
  )
)
```
#### Used functions

<details><summary  class = "block2"> <font color="blue"> parse_mtdata </font> __(click)__ </summary>
```{r}
#| echo: true
#| eval: false
parse_mtdata <- function(metadata){

    # check the structure of metadata

    #------------------------------#
    #------------------------------#


    #check the results

    return(list(variables = names(metadata$columns),
                string_variable = names(purrr::keep(metadata$columns, ~.x$type == "string")),
                domains = purrr::map_vec(metadata$columns, ~purrr::pluck(.x, 'domain'))  |>  unique(),
                header_variable = purrr::pluck(metadata, "header")$variable,
                header_order = purrr::pluck(metadata, "header")$order,
                population_variable = purrr::pluck(metadata, "population")$variable)
    )
}
```
</details>

<details><summary  class = "block2"> <font color="blue"> demo_t_generator </font> __(click)__ </summary>
```{r}
#| echo: true
#| eval: false

demo_t_generator <- function(dataset, columns, columns_label, string_variable, header_variable, header_order, population_variable){


    names(header_variable) <- NULL

    adsl <- dataset %>%
        select(USUBJID, all_of(population_variable), all_of(header_variable), all_of(header_order), all_of(columns)) %>%
        filter(!!as.name(population_variable) == "Y")
    # %>%
    #   mutate(across(string_variable, ~ifelse(.=="", "Missing_value_impute", as.character(.))))

    adsl_fact <- adsl %>%
        mutate(across(all_of(string_variable),
                      ~factor(attributes(cur_data()[[cur_column()]])$format$Decode[.x],
                              levels = attributes(cur_data()[[cur_column()]])$format$Decode)))

    if(isTRUE(is.na(header_order))){
        adsl_fact <- adsl_fact %>%
            mutate(across(all_of(header_variable),
                          ~factor(attributes(cur_data()[[cur_column()]])$format$Decode[.x],
                                  levels = attributes(cur_data()[[cur_column()]])$format$Decode)))
    }else{
        adsl_fact <- df_order_header(adsl_fact, c(header_variable, header_order))
    }



    col_counts <- table(adsl[[header_variable]]) %>% as.vector()
    col_counts <- c(col_counts, sum(col_counts))

    calculated_t <- basic_table() %>%
        split_cols_by(header_variable) %>%
        add_overall_col("All") %>%
        summarize_vars(
            vars = columns,
            var_labels = columns_label,
            dispfmt = c("npct"),
            decimal = 1,
            denom = c("col"),
            unique_row = TRUE
        ) %>%
        rtables::build_table(adsl_fact, col_counts = col_counts)

    return(calculated_t)
}



```
</details>



#### Steps
- initialize a new instance of `TLFProc`, add tlfmetadata `mock.yaml`
```{r}
tlfp <- TLFProc$new()

tlfp$add_tlfmetadata("mock.yaml")
```


<details><summary  class = "block2"> <font color="blue"> mock.yaml </font> __(click)__ </summary>

```{r}
#| echo: true
#| eval: false

demographic_example1:
  columns:
    AGEGR1:
      domain: adsl
      type: string
      label: Age Goup (n[%])
    AGE:
      domain: adsl
      type: numberic
      label: Age
      stats: N Mean Median Q1 Q3 Min Max
    SEX:
      domain: adsl
      type: string
      label: Sex (n[%])
  header:
    variable:
      TRT01A
    order:
      TRT01AN
  population:
    variable:
      SAFFL
demographic_example2:
  columns:
    RACE:
      domain: adsl
      type: string
      label: Race (n[%])
    AGEGR1N:
      domain: adsl
      type: string
      label: Age Goup (n[%])
    BMIBL:
      domain: adsl
      type: numberic
      label: Baseline BMI (kg/m^2)
      stats: N Mean Median Q1 Q3 Min Max
    BMIBLGR1:
      domain: adsl
      type: string
      label: Baseline BMI Agroup
  header:
    variable:
      SEX
    order:
      NULL
  population:
    variable:
      DISCONFL
```
</details>


<details><summary class = "block2">
```{r}
#| echo: true
#| eval: false
tlfp$tlfmetadata
```
</summary>
```{r}
#| echo: false
#| eval: true
tlfp$tlfmetadata
```

</details>


- Get all the needed datasets from metadata
```{r}
domains <- purrr::map(tlfp$tlfmetadata, ~purrr::pluck(.x, "domains"))  |>
        purrr::list_simplify()  |>
        unique()
```


- initialize a new instance of `VaribaleProc` with the dictionary of variables `dictionary.json`,
- load needed  datasets
- add attribute `format` to variables by `get_decode()`

```{r}
varpoc <- VariableProc$new()

varpoc$initialize(dictionary_path = "dictionary.json")

varpoc$load_dataset(path = "../../data/adam", domains = domains)
varpoc$get_decode()
```

<details><summary class = "block2"> <font color="blue"> dictionary.json </font> __(click)__ </summary>

```{r}
#| echo: true
#| eval: false
{
  "AGEGR1": {
    "<65": ["<65"],
    "65-80": ["65-80"],
    ">80": [">80"]
  },
    "AGEGR1N": {
    "1": ["<65"],
    "2": ["65-80"],
    "3": [">80"]
  },
  "SEX": {
    "M": ["Male"],
    "F": ["Female"]
  },
  "RACE": {
    "WHITE": ["White"],
    "BLACK OR AFRICAN AMERICAN": ["Black Or African American"],
    "AMERICAN INDIAN OR ALASKA NATIVE": ["American Indian Or Alaska Native"]
  },
  "BMIBLGR1": {
    "<25": ["<25"],
    "25-<30": ["25-<30"],
    ">=30": [">=30"]
  }
}
```
</details>


- Generate the outputs
```{r}
tlfp$generator(VariableProc = varpoc)
```

- Check what the outputs we have in `tlfp`
```{r}
tlfp$has_outputs()

tlfp$has_outputs("1")
```

- the tlf metadata of the table `demographic_example1`
```{r}
tlfp$tlfmetadata$demographic_example1
```

```{r}
#| echo: false
#| eval: true

#' Display rtables in html
#'
#' @param table a rtables object
#' @param to_html export to HTML. Default TRUE
#'
#' @return a html table
#' @export
table_to_html <- function(table, to_html = TRUE) {
  stopifnot(!is.null(table), class(table) %in% c("TableTree", "ElementaryTable"))
  extra_css <- "
  .tabwid {overflow-x: scroll; display: block;}
  .tabwid table td p {min-width: 170px !important;}
  .tabwid table td:first-child > p {min-width: 200px !important;}
  .tabwid table tr:hover {background-color: #ffff99 !important;}
  "
  flextable::set_flextable_defaults(
    font.family = ifelse(to_html, "Source Sans Pro", "Verdana"),
    extra_css = extra_css
  )
  ft <- rtables::tt_to_flextable(table) %>%
    flextable::border_remove() %>%
    flextable::bold(bold = TRUE, part = "header") %>%
    flextable::hline_top(part = "body") %>%
    flextable::hline_bottom(part = "body") %>%
    flextable::autofit()
  if (to_html) {
    flextable::htmltools_value(ft)
  } else {
    ft
  }
}
```

- Retrieve the outputs
```{r}
#| echo: true
#| eval: false
tlfp$get("demographic_example1")
```
```{r}
#| echo: false
#| eval: true
#| message: FALSE
table_to_html(tlfp$get("demographic_example1"), to_html = FALSE)
```

```{r}

tlfp$tlfmetadata$demographic_example1

```

```{r}
#| echo: true
#| eval: false
tlfp$get("demographic_example2")
```
```{r}
#| echo: false
#| eval: true
#| message: FALSE
table_to_html(tlfp$get("demographic_example2"), to_html = FALSE)
```
&nbsp;

- the size of tlfp
```{r}
print(object.size(tlfp))
```

- Transform the class of `rtables`
```{r}
table_to_dataframe <- function(tbl) {

  # check the tabl classs

  matrix_tbl <- tbl %>% rtables::matrix_form()

  tbl_strings <- as.data.frame(matrix_tbl$strings)


  ## get the hader index from tbl attributes
  nrow_header <- attributes(matrix_tbl)$nrow_header

  ## get the body of tbl
  tbl_body <- tbl_strings[-c(1:nrow_header), ]

  ## get the header of tbl
  tbl_header <- tbl_strings[c(1:nrow_header), ]

  attr(tbl_body, "tbl_header") <- tbl_header



  return(tbl_body)
}
```

```{r}
tbl <-  tlfp$get("demographic_example2") |> table_to_dataframe()
```
```{r du2 }
#| echo: false
#| eval: true
#| message: FALSE
knitr::kable(tbl, "html")%>%
  kableExtra::kable_styling(font_size = 16)
```
```{r}
attributes(tbl)
```
